
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = {
  id: number
  createdAt: Date
  updatedAt: Date
  email: string
  name: string
  password: string
  images: string[]
}

/**
 * Model Workout
 * 
 */
export type Workout = {
  id: number
  createdAt: Date
  updatedAt: Date
  name: string
}

/**
 * Model Exercise
 * 
 */
export type Exercise = {
  id: number
  createdAt: Date
  updatedAt: Date
  name: string
  times: number
  iconPath: string
}

/**
 * Model ExerciseLog
 * 
 */
export type ExerciseLog = {
  id: number
  createdAt: Date
  updatedAt: Date
  isCompleted: boolean
  userId: number | null
  workoutLogId: number | null
  exerciseId: number | null
}

/**
 * Model ExerciseTime
 * 
 */
export type ExerciseTime = {
  id: number
  createdAt: Date
  updatedAt: Date
  weight: number
  repeat: number
  isCompleted: boolean
  exerciseLogId: number | null
}

/**
 * Model WorkoutLog
 * 
 */
export type WorkoutLog = {
  id: number
  createdAt: Date
  updatedAt: Date
  isCompleted: boolean
  userId: number | null
  workoutId: number | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<GlobalReject>;

  /**
   * `prisma.workout`: Exposes CRUD operations for the **Workout** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workouts
    * const workouts = await prisma.workout.findMany()
    * ```
    */
  get workout(): Prisma.WorkoutDelegate<GlobalReject>;

  /**
   * `prisma.exercise`: Exposes CRUD operations for the **Exercise** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exercises
    * const exercises = await prisma.exercise.findMany()
    * ```
    */
  get exercise(): Prisma.ExerciseDelegate<GlobalReject>;

  /**
   * `prisma.exerciseLog`: Exposes CRUD operations for the **ExerciseLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseLogs
    * const exerciseLogs = await prisma.exerciseLog.findMany()
    * ```
    */
  get exerciseLog(): Prisma.ExerciseLogDelegate<GlobalReject>;

  /**
   * `prisma.exerciseTime`: Exposes CRUD operations for the **ExerciseTime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExerciseTimes
    * const exerciseTimes = await prisma.exerciseTime.findMany()
    * ```
    */
  get exerciseTime(): Prisma.ExerciseTimeDelegate<GlobalReject>;

  /**
   * `prisma.workoutLog`: Exposes CRUD operations for the **WorkoutLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkoutLogs
    * const workoutLogs = await prisma.workoutLog.findMany()
    * ```
    */
  get workoutLog(): Prisma.WorkoutLogDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.14.1
   * Query Engine version: 8fbc245156db7124f997f4cecdd8d1219e360944
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Workout: 'Workout',
    Exercise: 'Exercise',
    ExerciseLog: 'ExerciseLog',
    ExerciseTime: 'ExerciseTime',
    WorkoutLog: 'WorkoutLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    exerciseLogs: number
    workoutLogs: number
  }

  export type UserCountOutputTypeSelect = {
    exerciseLogs?: boolean
    workoutLogs?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkoutCountOutputType
   */


  export type WorkoutCountOutputType = {
    exercises: number
    workoutLogs: number
  }

  export type WorkoutCountOutputTypeSelect = {
    exercises?: boolean
    workoutLogs?: boolean
  }

  export type WorkoutCountOutputTypeGetPayload<S extends boolean | null | undefined | WorkoutCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorkoutCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WorkoutCountOutputTypeArgs)
    ? WorkoutCountOutputType 
    : S extends { select: any } & (WorkoutCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WorkoutCountOutputType ? WorkoutCountOutputType[P] : never
  } 
      : WorkoutCountOutputType




  // Custom InputTypes

  /**
   * WorkoutCountOutputType without action
   */
  export type WorkoutCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkoutCountOutputType
     */
    select?: WorkoutCountOutputTypeSelect | null
  }



  /**
   * Count Type ExerciseCountOutputType
   */


  export type ExerciseCountOutputType = {
    workouts: number
    exerciseLog: number
  }

  export type ExerciseCountOutputTypeSelect = {
    workouts?: boolean
    exerciseLog?: boolean
  }

  export type ExerciseCountOutputTypeGetPayload<S extends boolean | null | undefined | ExerciseCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ExerciseCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ExerciseCountOutputTypeArgs)
    ? ExerciseCountOutputType 
    : S extends { select: any } & (ExerciseCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ExerciseCountOutputType ? ExerciseCountOutputType[P] : never
  } 
      : ExerciseCountOutputType




  // Custom InputTypes

  /**
   * ExerciseCountOutputType without action
   */
  export type ExerciseCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ExerciseCountOutputType
     */
    select?: ExerciseCountOutputTypeSelect | null
  }



  /**
   * Count Type ExerciseLogCountOutputType
   */


  export type ExerciseLogCountOutputType = {
    times: number
  }

  export type ExerciseLogCountOutputTypeSelect = {
    times?: boolean
  }

  export type ExerciseLogCountOutputTypeGetPayload<S extends boolean | null | undefined | ExerciseLogCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ExerciseLogCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (ExerciseLogCountOutputTypeArgs)
    ? ExerciseLogCountOutputType 
    : S extends { select: any } & (ExerciseLogCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof ExerciseLogCountOutputType ? ExerciseLogCountOutputType[P] : never
  } 
      : ExerciseLogCountOutputType




  // Custom InputTypes

  /**
   * ExerciseLogCountOutputType without action
   */
  export type ExerciseLogCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLogCountOutputType
     */
    select?: ExerciseLogCountOutputTypeSelect | null
  }



  /**
   * Count Type WorkoutLogCountOutputType
   */


  export type WorkoutLogCountOutputType = {
    exerciseLogs: number
  }

  export type WorkoutLogCountOutputTypeSelect = {
    exerciseLogs?: boolean
  }

  export type WorkoutLogCountOutputTypeGetPayload<S extends boolean | null | undefined | WorkoutLogCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorkoutLogCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (WorkoutLogCountOutputTypeArgs)
    ? WorkoutLogCountOutputType 
    : S extends { select: any } & (WorkoutLogCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof WorkoutLogCountOutputType ? WorkoutLogCountOutputType[P] : never
  } 
      : WorkoutLogCountOutputType




  // Custom InputTypes

  /**
   * WorkoutLogCountOutputType without action
   */
  export type WorkoutLogCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WorkoutLogCountOutputType
     */
    select?: WorkoutLogCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model User
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    name: string | null
    password: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    email: string | null
    name: string | null
    password: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    email: number
    name: number
    password: number
    images: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    name?: true
    password?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    name?: true
    password?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    email?: true
    name?: true
    password?: true
    images?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: UserWhereInput
    orderBy?: Enumerable<UserOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    email: string
    name: string
    password: string
    images: string[]
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    email?: boolean
    name?: boolean
    password?: boolean
    images?: boolean
    exerciseLogs?: boolean | User$exerciseLogsArgs
    workoutLogs?: boolean | User$workoutLogsArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type UserInclude = {
    exerciseLogs?: boolean | User$exerciseLogsArgs
    workoutLogs?: boolean | User$workoutLogsArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type UserGetPayload<S extends boolean | null | undefined | UserArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? User :
    S extends undefined ? never :
    S extends { include: any } & (UserArgs | UserFindManyArgs)
    ? User  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'exerciseLogs' ? Array < ExerciseLogGetPayload<S['include'][P]>>  :
        P extends 'workoutLogs' ? Array < WorkoutLogGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (UserArgs | UserFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'exerciseLogs' ? Array < ExerciseLogGetPayload<S['select'][P]>>  :
        P extends 'workoutLogs' ? Array < WorkoutLogGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof User ? User[P] : never
  } 
      : User


  type UserCountArgs = 
    Omit<UserFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UserFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UserFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'User'> extends True ? Prisma__UserClient<UserGetPayload<T>> : Prisma__UserClient<UserGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs>
    ): Prisma.PrismaPromise<Array<UserGetPayload<T>>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Create many Users.
     *     @param {UserCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const user = await prisma.user.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs>
    ): Prisma__UserClient<UserGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UserClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    exerciseLogs<T extends User$exerciseLogsArgs= {}>(args?: Subset<T, User$exerciseLogsArgs>): Prisma.PrismaPromise<Array<ExerciseLogGetPayload<T>>| Null>;

    workoutLogs<T extends User$workoutLogsArgs= {}>(args?: Subset<T, User$workoutLogsArgs>): Prisma.PrismaPromise<Array<WorkoutLogGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * User base type for findUnique actions
   */
  export type UserFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUnique
   */
  export interface UserFindUniqueArgs extends UserFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User base type for findFirst actions
   */
  export type UserFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * User findFirst
   */
  export interface UserFindFirstArgs extends UserFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User findMany
   */
  export type UserFindManyArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: Enumerable<UserOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * User create
   */
  export type UserCreateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }


  /**
   * User createMany
   */
  export type UserCreateManyArgs = {
    /**
     * The data used to create many Users.
     */
    data: Enumerable<UserCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * User update
   */
  export type UserUpdateArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User updateMany
   */
  export type UserUpdateManyArgs = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }


  /**
   * User upsert
   */
  export type UserUpsertArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }


  /**
   * User delete
   */
  export type UserDeleteArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }


  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }


  /**
   * User.exerciseLogs
   */
  export type User$exerciseLogsArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    where?: ExerciseLogWhereInput
    orderBy?: Enumerable<ExerciseLogOrderByWithRelationInput>
    cursor?: ExerciseLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ExerciseLogScalarFieldEnum>
  }


  /**
   * User.workoutLogs
   */
  export type User$workoutLogsArgs = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
    where?: WorkoutLogWhereInput
    orderBy?: Enumerable<WorkoutLogOrderByWithRelationInput>
    cursor?: WorkoutLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkoutLogScalarFieldEnum>
  }


  /**
   * User without action
   */
  export type UserArgs = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: UserInclude | null
  }



  /**
   * Model Workout
   */


  export type AggregateWorkout = {
    _count: WorkoutCountAggregateOutputType | null
    _avg: WorkoutAvgAggregateOutputType | null
    _sum: WorkoutSumAggregateOutputType | null
    _min: WorkoutMinAggregateOutputType | null
    _max: WorkoutMaxAggregateOutputType | null
  }

  export type WorkoutAvgAggregateOutputType = {
    id: number | null
  }

  export type WorkoutSumAggregateOutputType = {
    id: number | null
  }

  export type WorkoutMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
  }

  export type WorkoutMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
  }

  export type WorkoutCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    _all: number
  }


  export type WorkoutAvgAggregateInputType = {
    id?: true
  }

  export type WorkoutSumAggregateInputType = {
    id?: true
  }

  export type WorkoutMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
  }

  export type WorkoutMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
  }

  export type WorkoutCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    _all?: true
  }

  export type WorkoutAggregateArgs = {
    /**
     * Filter which Workout to aggregate.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: Enumerable<WorkoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workouts
    **/
    _count?: true | WorkoutCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutMaxAggregateInputType
  }

  export type GetWorkoutAggregateType<T extends WorkoutAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkout]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkout[P]>
      : GetScalarType<T[P], AggregateWorkout[P]>
  }




  export type WorkoutGroupByArgs = {
    where?: WorkoutWhereInput
    orderBy?: Enumerable<WorkoutOrderByWithAggregationInput>
    by: WorkoutScalarFieldEnum[]
    having?: WorkoutScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutCountAggregateInputType | true
    _avg?: WorkoutAvgAggregateInputType
    _sum?: WorkoutSumAggregateInputType
    _min?: WorkoutMinAggregateInputType
    _max?: WorkoutMaxAggregateInputType
  }


  export type WorkoutGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    _count: WorkoutCountAggregateOutputType | null
    _avg: WorkoutAvgAggregateOutputType | null
    _sum: WorkoutSumAggregateOutputType | null
    _min: WorkoutMinAggregateOutputType | null
    _max: WorkoutMaxAggregateOutputType | null
  }

  type GetWorkoutGroupByPayload<T extends WorkoutGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WorkoutGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    exercises?: boolean | Workout$exercisesArgs
    workoutLogs?: boolean | Workout$workoutLogsArgs
    _count?: boolean | WorkoutCountOutputTypeArgs
  }


  export type WorkoutInclude = {
    exercises?: boolean | Workout$exercisesArgs
    workoutLogs?: boolean | Workout$workoutLogsArgs
    _count?: boolean | WorkoutCountOutputTypeArgs
  }

  export type WorkoutGetPayload<S extends boolean | null | undefined | WorkoutArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Workout :
    S extends undefined ? never :
    S extends { include: any } & (WorkoutArgs | WorkoutFindManyArgs)
    ? Workout  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'exercises' ? Array < ExerciseGetPayload<S['include'][P]>>  :
        P extends 'workoutLogs' ? Array < WorkoutLogGetPayload<S['include'][P]>>  :
        P extends '_count' ? WorkoutCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WorkoutArgs | WorkoutFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'exercises' ? Array < ExerciseGetPayload<S['select'][P]>>  :
        P extends 'workoutLogs' ? Array < WorkoutLogGetPayload<S['select'][P]>>  :
        P extends '_count' ? WorkoutCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Workout ? Workout[P] : never
  } 
      : Workout


  type WorkoutCountArgs = 
    Omit<WorkoutFindManyArgs, 'select' | 'include'> & {
      select?: WorkoutCountAggregateInputType | true
    }

  export interface WorkoutDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Workout that matches the filter.
     * @param {WorkoutFindUniqueArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkoutFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkoutFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Workout'> extends True ? Prisma__WorkoutClient<WorkoutGetPayload<T>> : Prisma__WorkoutClient<WorkoutGetPayload<T> | null, null>

    /**
     * Find one Workout that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WorkoutFindUniqueOrThrowArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkoutFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WorkoutFindUniqueOrThrowArgs>
    ): Prisma__WorkoutClient<WorkoutGetPayload<T>>

    /**
     * Find the first Workout that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindFirstArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkoutFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkoutFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Workout'> extends True ? Prisma__WorkoutClient<WorkoutGetPayload<T>> : Prisma__WorkoutClient<WorkoutGetPayload<T> | null, null>

    /**
     * Find the first Workout that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindFirstOrThrowArgs} args - Arguments to find a Workout
     * @example
     * // Get one Workout
     * const workout = await prisma.workout.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkoutFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkoutFindFirstOrThrowArgs>
    ): Prisma__WorkoutClient<WorkoutGetPayload<T>>

    /**
     * Find zero or more Workouts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workouts
     * const workouts = await prisma.workout.findMany()
     * 
     * // Get first 10 Workouts
     * const workouts = await prisma.workout.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutWithIdOnly = await prisma.workout.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkoutFindManyArgs>(
      args?: SelectSubset<T, WorkoutFindManyArgs>
    ): Prisma.PrismaPromise<Array<WorkoutGetPayload<T>>>

    /**
     * Create a Workout.
     * @param {WorkoutCreateArgs} args - Arguments to create a Workout.
     * @example
     * // Create one Workout
     * const Workout = await prisma.workout.create({
     *   data: {
     *     // ... data to create a Workout
     *   }
     * })
     * 
    **/
    create<T extends WorkoutCreateArgs>(
      args: SelectSubset<T, WorkoutCreateArgs>
    ): Prisma__WorkoutClient<WorkoutGetPayload<T>>

    /**
     * Create many Workouts.
     *     @param {WorkoutCreateManyArgs} args - Arguments to create many Workouts.
     *     @example
     *     // Create many Workouts
     *     const workout = await prisma.workout.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkoutCreateManyArgs>(
      args?: SelectSubset<T, WorkoutCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Workout.
     * @param {WorkoutDeleteArgs} args - Arguments to delete one Workout.
     * @example
     * // Delete one Workout
     * const Workout = await prisma.workout.delete({
     *   where: {
     *     // ... filter to delete one Workout
     *   }
     * })
     * 
    **/
    delete<T extends WorkoutDeleteArgs>(
      args: SelectSubset<T, WorkoutDeleteArgs>
    ): Prisma__WorkoutClient<WorkoutGetPayload<T>>

    /**
     * Update one Workout.
     * @param {WorkoutUpdateArgs} args - Arguments to update one Workout.
     * @example
     * // Update one Workout
     * const workout = await prisma.workout.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkoutUpdateArgs>(
      args: SelectSubset<T, WorkoutUpdateArgs>
    ): Prisma__WorkoutClient<WorkoutGetPayload<T>>

    /**
     * Delete zero or more Workouts.
     * @param {WorkoutDeleteManyArgs} args - Arguments to filter Workouts to delete.
     * @example
     * // Delete a few Workouts
     * const { count } = await prisma.workout.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkoutDeleteManyArgs>(
      args?: SelectSubset<T, WorkoutDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workouts
     * const workout = await prisma.workout.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkoutUpdateManyArgs>(
      args: SelectSubset<T, WorkoutUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workout.
     * @param {WorkoutUpsertArgs} args - Arguments to update or create a Workout.
     * @example
     * // Update or create a Workout
     * const workout = await prisma.workout.upsert({
     *   create: {
     *     // ... data to create a Workout
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workout we want to update
     *   }
     * })
    **/
    upsert<T extends WorkoutUpsertArgs>(
      args: SelectSubset<T, WorkoutUpsertArgs>
    ): Prisma__WorkoutClient<WorkoutGetPayload<T>>

    /**
     * Count the number of Workouts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutCountArgs} args - Arguments to filter Workouts to count.
     * @example
     * // Count the number of Workouts
     * const count = await prisma.workout.count({
     *   where: {
     *     // ... the filter for the Workouts we want to count
     *   }
     * })
    **/
    count<T extends WorkoutCountArgs>(
      args?: Subset<T, WorkoutCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutAggregateArgs>(args: Subset<T, WorkoutAggregateArgs>): Prisma.PrismaPromise<GetWorkoutAggregateType<T>>

    /**
     * Group by Workout.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Workout.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkoutClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    exercises<T extends Workout$exercisesArgs= {}>(args?: Subset<T, Workout$exercisesArgs>): Prisma.PrismaPromise<Array<ExerciseGetPayload<T>>| Null>;

    workoutLogs<T extends Workout$workoutLogsArgs= {}>(args?: Subset<T, Workout$workoutLogsArgs>): Prisma.PrismaPromise<Array<WorkoutLogGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Workout base type for findUnique actions
   */
  export type WorkoutFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutInclude | null
    /**
     * Filter, which Workout to fetch.
     */
    where: WorkoutWhereUniqueInput
  }

  /**
   * Workout findUnique
   */
  export interface WorkoutFindUniqueArgs extends WorkoutFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Workout findUniqueOrThrow
   */
  export type WorkoutFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutInclude | null
    /**
     * Filter, which Workout to fetch.
     */
    where: WorkoutWhereUniqueInput
  }


  /**
   * Workout base type for findFirst actions
   */
  export type WorkoutFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutInclude | null
    /**
     * Filter, which Workout to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: Enumerable<WorkoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workouts.
     */
    distinct?: Enumerable<WorkoutScalarFieldEnum>
  }

  /**
   * Workout findFirst
   */
  export interface WorkoutFindFirstArgs extends WorkoutFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Workout findFirstOrThrow
   */
  export type WorkoutFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutInclude | null
    /**
     * Filter, which Workout to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: Enumerable<WorkoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workouts.
     */
    distinct?: Enumerable<WorkoutScalarFieldEnum>
  }


  /**
   * Workout findMany
   */
  export type WorkoutFindManyArgs = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutInclude | null
    /**
     * Filter, which Workouts to fetch.
     */
    where?: WorkoutWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workouts to fetch.
     */
    orderBy?: Enumerable<WorkoutOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workouts.
     */
    cursor?: WorkoutWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workouts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workouts.
     */
    skip?: number
    distinct?: Enumerable<WorkoutScalarFieldEnum>
  }


  /**
   * Workout create
   */
  export type WorkoutCreateArgs = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutInclude | null
    /**
     * The data needed to create a Workout.
     */
    data: XOR<WorkoutCreateInput, WorkoutUncheckedCreateInput>
  }


  /**
   * Workout createMany
   */
  export type WorkoutCreateManyArgs = {
    /**
     * The data used to create many Workouts.
     */
    data: Enumerable<WorkoutCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Workout update
   */
  export type WorkoutUpdateArgs = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutInclude | null
    /**
     * The data needed to update a Workout.
     */
    data: XOR<WorkoutUpdateInput, WorkoutUncheckedUpdateInput>
    /**
     * Choose, which Workout to update.
     */
    where: WorkoutWhereUniqueInput
  }


  /**
   * Workout updateMany
   */
  export type WorkoutUpdateManyArgs = {
    /**
     * The data used to update Workouts.
     */
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyInput>
    /**
     * Filter which Workouts to update
     */
    where?: WorkoutWhereInput
  }


  /**
   * Workout upsert
   */
  export type WorkoutUpsertArgs = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutInclude | null
    /**
     * The filter to search for the Workout to update in case it exists.
     */
    where: WorkoutWhereUniqueInput
    /**
     * In case the Workout found by the `where` argument doesn't exist, create a new Workout with this data.
     */
    create: XOR<WorkoutCreateInput, WorkoutUncheckedCreateInput>
    /**
     * In case the Workout was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutUpdateInput, WorkoutUncheckedUpdateInput>
  }


  /**
   * Workout delete
   */
  export type WorkoutDeleteArgs = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutInclude | null
    /**
     * Filter which Workout to delete.
     */
    where: WorkoutWhereUniqueInput
  }


  /**
   * Workout deleteMany
   */
  export type WorkoutDeleteManyArgs = {
    /**
     * Filter which Workouts to delete
     */
    where?: WorkoutWhereInput
  }


  /**
   * Workout.exercises
   */
  export type Workout$exercisesArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude | null
    where?: ExerciseWhereInput
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    cursor?: ExerciseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ExerciseScalarFieldEnum>
  }


  /**
   * Workout.workoutLogs
   */
  export type Workout$workoutLogsArgs = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
    where?: WorkoutLogWhereInput
    orderBy?: Enumerable<WorkoutLogOrderByWithRelationInput>
    cursor?: WorkoutLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkoutLogScalarFieldEnum>
  }


  /**
   * Workout without action
   */
  export type WorkoutArgs = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutInclude | null
  }



  /**
   * Model Exercise
   */


  export type AggregateExercise = {
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  export type ExerciseAvgAggregateOutputType = {
    id: number | null
    times: number | null
  }

  export type ExerciseSumAggregateOutputType = {
    id: number | null
    times: number | null
  }

  export type ExerciseMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    times: number | null
    iconPath: string | null
  }

  export type ExerciseMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    name: string | null
    times: number | null
    iconPath: string | null
  }

  export type ExerciseCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    name: number
    times: number
    iconPath: number
    _all: number
  }


  export type ExerciseAvgAggregateInputType = {
    id?: true
    times?: true
  }

  export type ExerciseSumAggregateInputType = {
    id?: true
    times?: true
  }

  export type ExerciseMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    times?: true
    iconPath?: true
  }

  export type ExerciseMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    times?: true
    iconPath?: true
  }

  export type ExerciseCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    name?: true
    times?: true
    iconPath?: true
    _all?: true
  }

  export type ExerciseAggregateArgs = {
    /**
     * Filter which Exercise to aggregate.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exercises
    **/
    _count?: true | ExerciseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseMaxAggregateInputType
  }

  export type GetExerciseAggregateType<T extends ExerciseAggregateArgs> = {
        [P in keyof T & keyof AggregateExercise]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExercise[P]>
      : GetScalarType<T[P], AggregateExercise[P]>
  }




  export type ExerciseGroupByArgs = {
    where?: ExerciseWhereInput
    orderBy?: Enumerable<ExerciseOrderByWithAggregationInput>
    by: ExerciseScalarFieldEnum[]
    having?: ExerciseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseCountAggregateInputType | true
    _avg?: ExerciseAvgAggregateInputType
    _sum?: ExerciseSumAggregateInputType
    _min?: ExerciseMinAggregateInputType
    _max?: ExerciseMaxAggregateInputType
  }


  export type ExerciseGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    name: string
    times: number
    iconPath: string
    _count: ExerciseCountAggregateOutputType | null
    _avg: ExerciseAvgAggregateOutputType | null
    _sum: ExerciseSumAggregateOutputType | null
    _min: ExerciseMinAggregateOutputType | null
    _max: ExerciseMaxAggregateOutputType | null
  }

  type GetExerciseGroupByPayload<T extends ExerciseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ExerciseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    name?: boolean
    times?: boolean
    iconPath?: boolean
    workouts?: boolean | Exercise$workoutsArgs
    exerciseLog?: boolean | Exercise$exerciseLogArgs
    _count?: boolean | ExerciseCountOutputTypeArgs
  }


  export type ExerciseInclude = {
    workouts?: boolean | Exercise$workoutsArgs
    exerciseLog?: boolean | Exercise$exerciseLogArgs
    _count?: boolean | ExerciseCountOutputTypeArgs
  }

  export type ExerciseGetPayload<S extends boolean | null | undefined | ExerciseArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Exercise :
    S extends undefined ? never :
    S extends { include: any } & (ExerciseArgs | ExerciseFindManyArgs)
    ? Exercise  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'workouts' ? Array < WorkoutGetPayload<S['include'][P]>>  :
        P extends 'exerciseLog' ? Array < ExerciseLogGetPayload<S['include'][P]>>  :
        P extends '_count' ? ExerciseCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ExerciseArgs | ExerciseFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'workouts' ? Array < WorkoutGetPayload<S['select'][P]>>  :
        P extends 'exerciseLog' ? Array < ExerciseLogGetPayload<S['select'][P]>>  :
        P extends '_count' ? ExerciseCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Exercise ? Exercise[P] : never
  } 
      : Exercise


  type ExerciseCountArgs = 
    Omit<ExerciseFindManyArgs, 'select' | 'include'> & {
      select?: ExerciseCountAggregateInputType | true
    }

  export interface ExerciseDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Exercise that matches the filter.
     * @param {ExerciseFindUniqueArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExerciseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExerciseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Exercise'> extends True ? Prisma__ExerciseClient<ExerciseGetPayload<T>> : Prisma__ExerciseClient<ExerciseGetPayload<T> | null, null>

    /**
     * Find one Exercise that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ExerciseFindUniqueOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExerciseFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ExerciseFindUniqueOrThrowArgs>
    ): Prisma__ExerciseClient<ExerciseGetPayload<T>>

    /**
     * Find the first Exercise that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExerciseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExerciseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Exercise'> extends True ? Prisma__ExerciseClient<ExerciseGetPayload<T>> : Prisma__ExerciseClient<ExerciseGetPayload<T> | null, null>

    /**
     * Find the first Exercise that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindFirstOrThrowArgs} args - Arguments to find a Exercise
     * @example
     * // Get one Exercise
     * const exercise = await prisma.exercise.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExerciseFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExerciseFindFirstOrThrowArgs>
    ): Prisma__ExerciseClient<ExerciseGetPayload<T>>

    /**
     * Find zero or more Exercises that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exercises
     * const exercises = await prisma.exercise.findMany()
     * 
     * // Get first 10 Exercises
     * const exercises = await prisma.exercise.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseWithIdOnly = await prisma.exercise.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExerciseFindManyArgs>(
      args?: SelectSubset<T, ExerciseFindManyArgs>
    ): Prisma.PrismaPromise<Array<ExerciseGetPayload<T>>>

    /**
     * Create a Exercise.
     * @param {ExerciseCreateArgs} args - Arguments to create a Exercise.
     * @example
     * // Create one Exercise
     * const Exercise = await prisma.exercise.create({
     *   data: {
     *     // ... data to create a Exercise
     *   }
     * })
     * 
    **/
    create<T extends ExerciseCreateArgs>(
      args: SelectSubset<T, ExerciseCreateArgs>
    ): Prisma__ExerciseClient<ExerciseGetPayload<T>>

    /**
     * Create many Exercises.
     *     @param {ExerciseCreateManyArgs} args - Arguments to create many Exercises.
     *     @example
     *     // Create many Exercises
     *     const exercise = await prisma.exercise.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExerciseCreateManyArgs>(
      args?: SelectSubset<T, ExerciseCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exercise.
     * @param {ExerciseDeleteArgs} args - Arguments to delete one Exercise.
     * @example
     * // Delete one Exercise
     * const Exercise = await prisma.exercise.delete({
     *   where: {
     *     // ... filter to delete one Exercise
     *   }
     * })
     * 
    **/
    delete<T extends ExerciseDeleteArgs>(
      args: SelectSubset<T, ExerciseDeleteArgs>
    ): Prisma__ExerciseClient<ExerciseGetPayload<T>>

    /**
     * Update one Exercise.
     * @param {ExerciseUpdateArgs} args - Arguments to update one Exercise.
     * @example
     * // Update one Exercise
     * const exercise = await prisma.exercise.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExerciseUpdateArgs>(
      args: SelectSubset<T, ExerciseUpdateArgs>
    ): Prisma__ExerciseClient<ExerciseGetPayload<T>>

    /**
     * Delete zero or more Exercises.
     * @param {ExerciseDeleteManyArgs} args - Arguments to filter Exercises to delete.
     * @example
     * // Delete a few Exercises
     * const { count } = await prisma.exercise.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExerciseDeleteManyArgs>(
      args?: SelectSubset<T, ExerciseDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exercises
     * const exercise = await prisma.exercise.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExerciseUpdateManyArgs>(
      args: SelectSubset<T, ExerciseUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exercise.
     * @param {ExerciseUpsertArgs} args - Arguments to update or create a Exercise.
     * @example
     * // Update or create a Exercise
     * const exercise = await prisma.exercise.upsert({
     *   create: {
     *     // ... data to create a Exercise
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exercise we want to update
     *   }
     * })
    **/
    upsert<T extends ExerciseUpsertArgs>(
      args: SelectSubset<T, ExerciseUpsertArgs>
    ): Prisma__ExerciseClient<ExerciseGetPayload<T>>

    /**
     * Count the number of Exercises.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseCountArgs} args - Arguments to filter Exercises to count.
     * @example
     * // Count the number of Exercises
     * const count = await prisma.exercise.count({
     *   where: {
     *     // ... the filter for the Exercises we want to count
     *   }
     * })
    **/
    count<T extends ExerciseCountArgs>(
      args?: Subset<T, ExerciseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseAggregateArgs>(args: Subset<T, ExerciseAggregateArgs>): Prisma.PrismaPromise<GetExerciseAggregateType<T>>

    /**
     * Group by Exercise.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for Exercise.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExerciseClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    workouts<T extends Exercise$workoutsArgs= {}>(args?: Subset<T, Exercise$workoutsArgs>): Prisma.PrismaPromise<Array<WorkoutGetPayload<T>>| Null>;

    exerciseLog<T extends Exercise$exerciseLogArgs= {}>(args?: Subset<T, Exercise$exerciseLogArgs>): Prisma.PrismaPromise<Array<ExerciseLogGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * Exercise base type for findUnique actions
   */
  export type ExerciseFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }

  /**
   * Exercise findUnique
   */
  export interface ExerciseFindUniqueArgs extends ExerciseFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Exercise findUniqueOrThrow
   */
  export type ExerciseFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude | null
    /**
     * Filter, which Exercise to fetch.
     */
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise base type for findFirst actions
   */
  export type ExerciseFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: Enumerable<ExerciseScalarFieldEnum>
  }

  /**
   * Exercise findFirst
   */
  export interface ExerciseFindFirstArgs extends ExerciseFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * Exercise findFirstOrThrow
   */
  export type ExerciseFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude | null
    /**
     * Filter, which Exercise to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exercises.
     */
    distinct?: Enumerable<ExerciseScalarFieldEnum>
  }


  /**
   * Exercise findMany
   */
  export type ExerciseFindManyArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude | null
    /**
     * Filter, which Exercises to fetch.
     */
    where?: ExerciseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exercises to fetch.
     */
    orderBy?: Enumerable<ExerciseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exercises.
     */
    cursor?: ExerciseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exercises from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exercises.
     */
    skip?: number
    distinct?: Enumerable<ExerciseScalarFieldEnum>
  }


  /**
   * Exercise create
   */
  export type ExerciseCreateArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude | null
    /**
     * The data needed to create a Exercise.
     */
    data: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
  }


  /**
   * Exercise createMany
   */
  export type ExerciseCreateManyArgs = {
    /**
     * The data used to create many Exercises.
     */
    data: Enumerable<ExerciseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Exercise update
   */
  export type ExerciseUpdateArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude | null
    /**
     * The data needed to update a Exercise.
     */
    data: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
    /**
     * Choose, which Exercise to update.
     */
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise updateMany
   */
  export type ExerciseUpdateManyArgs = {
    /**
     * The data used to update Exercises.
     */
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyInput>
    /**
     * Filter which Exercises to update
     */
    where?: ExerciseWhereInput
  }


  /**
   * Exercise upsert
   */
  export type ExerciseUpsertArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude | null
    /**
     * The filter to search for the Exercise to update in case it exists.
     */
    where: ExerciseWhereUniqueInput
    /**
     * In case the Exercise found by the `where` argument doesn't exist, create a new Exercise with this data.
     */
    create: XOR<ExerciseCreateInput, ExerciseUncheckedCreateInput>
    /**
     * In case the Exercise was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseUpdateInput, ExerciseUncheckedUpdateInput>
  }


  /**
   * Exercise delete
   */
  export type ExerciseDeleteArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude | null
    /**
     * Filter which Exercise to delete.
     */
    where: ExerciseWhereUniqueInput
  }


  /**
   * Exercise deleteMany
   */
  export type ExerciseDeleteManyArgs = {
    /**
     * Filter which Exercises to delete
     */
    where?: ExerciseWhereInput
  }


  /**
   * Exercise.workouts
   */
  export type Exercise$workoutsArgs = {
    /**
     * Select specific fields to fetch from the Workout
     */
    select?: WorkoutSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutInclude | null
    where?: WorkoutWhereInput
    orderBy?: Enumerable<WorkoutOrderByWithRelationInput>
    cursor?: WorkoutWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<WorkoutScalarFieldEnum>
  }


  /**
   * Exercise.exerciseLog
   */
  export type Exercise$exerciseLogArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    where?: ExerciseLogWhereInput
    orderBy?: Enumerable<ExerciseLogOrderByWithRelationInput>
    cursor?: ExerciseLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ExerciseLogScalarFieldEnum>
  }


  /**
   * Exercise without action
   */
  export type ExerciseArgs = {
    /**
     * Select specific fields to fetch from the Exercise
     */
    select?: ExerciseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseInclude | null
  }



  /**
   * Model ExerciseLog
   */


  export type AggregateExerciseLog = {
    _count: ExerciseLogCountAggregateOutputType | null
    _avg: ExerciseLogAvgAggregateOutputType | null
    _sum: ExerciseLogSumAggregateOutputType | null
    _min: ExerciseLogMinAggregateOutputType | null
    _max: ExerciseLogMaxAggregateOutputType | null
  }

  export type ExerciseLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    workoutLogId: number | null
    exerciseId: number | null
  }

  export type ExerciseLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    workoutLogId: number | null
    exerciseId: number | null
  }

  export type ExerciseLogMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isCompleted: boolean | null
    userId: number | null
    workoutLogId: number | null
    exerciseId: number | null
  }

  export type ExerciseLogMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isCompleted: boolean | null
    userId: number | null
    workoutLogId: number | null
    exerciseId: number | null
  }

  export type ExerciseLogCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isCompleted: number
    userId: number
    workoutLogId: number
    exerciseId: number
    _all: number
  }


  export type ExerciseLogAvgAggregateInputType = {
    id?: true
    userId?: true
    workoutLogId?: true
    exerciseId?: true
  }

  export type ExerciseLogSumAggregateInputType = {
    id?: true
    userId?: true
    workoutLogId?: true
    exerciseId?: true
  }

  export type ExerciseLogMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isCompleted?: true
    userId?: true
    workoutLogId?: true
    exerciseId?: true
  }

  export type ExerciseLogMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isCompleted?: true
    userId?: true
    workoutLogId?: true
    exerciseId?: true
  }

  export type ExerciseLogCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isCompleted?: true
    userId?: true
    workoutLogId?: true
    exerciseId?: true
    _all?: true
  }

  export type ExerciseLogAggregateArgs = {
    /**
     * Filter which ExerciseLog to aggregate.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: Enumerable<ExerciseLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseLogs
    **/
    _count?: true | ExerciseLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseLogMaxAggregateInputType
  }

  export type GetExerciseLogAggregateType<T extends ExerciseLogAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseLog[P]>
      : GetScalarType<T[P], AggregateExerciseLog[P]>
  }




  export type ExerciseLogGroupByArgs = {
    where?: ExerciseLogWhereInput
    orderBy?: Enumerable<ExerciseLogOrderByWithAggregationInput>
    by: ExerciseLogScalarFieldEnum[]
    having?: ExerciseLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseLogCountAggregateInputType | true
    _avg?: ExerciseLogAvgAggregateInputType
    _sum?: ExerciseLogSumAggregateInputType
    _min?: ExerciseLogMinAggregateInputType
    _max?: ExerciseLogMaxAggregateInputType
  }


  export type ExerciseLogGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isCompleted: boolean
    userId: number | null
    workoutLogId: number | null
    exerciseId: number | null
    _count: ExerciseLogCountAggregateOutputType | null
    _avg: ExerciseLogAvgAggregateOutputType | null
    _sum: ExerciseLogSumAggregateOutputType | null
    _min: ExerciseLogMinAggregateOutputType | null
    _max: ExerciseLogMaxAggregateOutputType | null
  }

  type GetExerciseLogGroupByPayload<T extends ExerciseLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ExerciseLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseLogGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseLogGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseLogSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isCompleted?: boolean
    userId?: boolean
    workoutLogId?: boolean
    exerciseId?: boolean
    times?: boolean | ExerciseLog$timesArgs
    user?: boolean | UserArgs
    workoutLog?: boolean | WorkoutLogArgs
    exercise?: boolean | ExerciseArgs
    _count?: boolean | ExerciseLogCountOutputTypeArgs
  }


  export type ExerciseLogInclude = {
    times?: boolean | ExerciseLog$timesArgs
    user?: boolean | UserArgs
    workoutLog?: boolean | WorkoutLogArgs
    exercise?: boolean | ExerciseArgs
    _count?: boolean | ExerciseLogCountOutputTypeArgs
  }

  export type ExerciseLogGetPayload<S extends boolean | null | undefined | ExerciseLogArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ExerciseLog :
    S extends undefined ? never :
    S extends { include: any } & (ExerciseLogArgs | ExerciseLogFindManyArgs)
    ? ExerciseLog  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'times' ? Array < ExerciseTimeGetPayload<S['include'][P]>>  :
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'workoutLog' ? WorkoutLogGetPayload<S['include'][P]> | null :
        P extends 'exercise' ? ExerciseGetPayload<S['include'][P]> | null :
        P extends '_count' ? ExerciseLogCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (ExerciseLogArgs | ExerciseLogFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'times' ? Array < ExerciseTimeGetPayload<S['select'][P]>>  :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'workoutLog' ? WorkoutLogGetPayload<S['select'][P]> | null :
        P extends 'exercise' ? ExerciseGetPayload<S['select'][P]> | null :
        P extends '_count' ? ExerciseLogCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof ExerciseLog ? ExerciseLog[P] : never
  } 
      : ExerciseLog


  type ExerciseLogCountArgs = 
    Omit<ExerciseLogFindManyArgs, 'select' | 'include'> & {
      select?: ExerciseLogCountAggregateInputType | true
    }

  export interface ExerciseLogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ExerciseLog that matches the filter.
     * @param {ExerciseLogFindUniqueArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExerciseLogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExerciseLogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ExerciseLog'> extends True ? Prisma__ExerciseLogClient<ExerciseLogGetPayload<T>> : Prisma__ExerciseLogClient<ExerciseLogGetPayload<T> | null, null>

    /**
     * Find one ExerciseLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ExerciseLogFindUniqueOrThrowArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExerciseLogFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ExerciseLogFindUniqueOrThrowArgs>
    ): Prisma__ExerciseLogClient<ExerciseLogGetPayload<T>>

    /**
     * Find the first ExerciseLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogFindFirstArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExerciseLogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExerciseLogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ExerciseLog'> extends True ? Prisma__ExerciseLogClient<ExerciseLogGetPayload<T>> : Prisma__ExerciseLogClient<ExerciseLogGetPayload<T> | null, null>

    /**
     * Find the first ExerciseLog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogFindFirstOrThrowArgs} args - Arguments to find a ExerciseLog
     * @example
     * // Get one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExerciseLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExerciseLogFindFirstOrThrowArgs>
    ): Prisma__ExerciseLogClient<ExerciseLogGetPayload<T>>

    /**
     * Find zero or more ExerciseLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseLogs
     * const exerciseLogs = await prisma.exerciseLog.findMany()
     * 
     * // Get first 10 ExerciseLogs
     * const exerciseLogs = await prisma.exerciseLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseLogWithIdOnly = await prisma.exerciseLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExerciseLogFindManyArgs>(
      args?: SelectSubset<T, ExerciseLogFindManyArgs>
    ): Prisma.PrismaPromise<Array<ExerciseLogGetPayload<T>>>

    /**
     * Create a ExerciseLog.
     * @param {ExerciseLogCreateArgs} args - Arguments to create a ExerciseLog.
     * @example
     * // Create one ExerciseLog
     * const ExerciseLog = await prisma.exerciseLog.create({
     *   data: {
     *     // ... data to create a ExerciseLog
     *   }
     * })
     * 
    **/
    create<T extends ExerciseLogCreateArgs>(
      args: SelectSubset<T, ExerciseLogCreateArgs>
    ): Prisma__ExerciseLogClient<ExerciseLogGetPayload<T>>

    /**
     * Create many ExerciseLogs.
     *     @param {ExerciseLogCreateManyArgs} args - Arguments to create many ExerciseLogs.
     *     @example
     *     // Create many ExerciseLogs
     *     const exerciseLog = await prisma.exerciseLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExerciseLogCreateManyArgs>(
      args?: SelectSubset<T, ExerciseLogCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExerciseLog.
     * @param {ExerciseLogDeleteArgs} args - Arguments to delete one ExerciseLog.
     * @example
     * // Delete one ExerciseLog
     * const ExerciseLog = await prisma.exerciseLog.delete({
     *   where: {
     *     // ... filter to delete one ExerciseLog
     *   }
     * })
     * 
    **/
    delete<T extends ExerciseLogDeleteArgs>(
      args: SelectSubset<T, ExerciseLogDeleteArgs>
    ): Prisma__ExerciseLogClient<ExerciseLogGetPayload<T>>

    /**
     * Update one ExerciseLog.
     * @param {ExerciseLogUpdateArgs} args - Arguments to update one ExerciseLog.
     * @example
     * // Update one ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExerciseLogUpdateArgs>(
      args: SelectSubset<T, ExerciseLogUpdateArgs>
    ): Prisma__ExerciseLogClient<ExerciseLogGetPayload<T>>

    /**
     * Delete zero or more ExerciseLogs.
     * @param {ExerciseLogDeleteManyArgs} args - Arguments to filter ExerciseLogs to delete.
     * @example
     * // Delete a few ExerciseLogs
     * const { count } = await prisma.exerciseLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExerciseLogDeleteManyArgs>(
      args?: SelectSubset<T, ExerciseLogDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseLogs
     * const exerciseLog = await prisma.exerciseLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExerciseLogUpdateManyArgs>(
      args: SelectSubset<T, ExerciseLogUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExerciseLog.
     * @param {ExerciseLogUpsertArgs} args - Arguments to update or create a ExerciseLog.
     * @example
     * // Update or create a ExerciseLog
     * const exerciseLog = await prisma.exerciseLog.upsert({
     *   create: {
     *     // ... data to create a ExerciseLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseLog we want to update
     *   }
     * })
    **/
    upsert<T extends ExerciseLogUpsertArgs>(
      args: SelectSubset<T, ExerciseLogUpsertArgs>
    ): Prisma__ExerciseLogClient<ExerciseLogGetPayload<T>>

    /**
     * Count the number of ExerciseLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogCountArgs} args - Arguments to filter ExerciseLogs to count.
     * @example
     * // Count the number of ExerciseLogs
     * const count = await prisma.exerciseLog.count({
     *   where: {
     *     // ... the filter for the ExerciseLogs we want to count
     *   }
     * })
    **/
    count<T extends ExerciseLogCountArgs>(
      args?: Subset<T, ExerciseLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseLogAggregateArgs>(args: Subset<T, ExerciseLogAggregateArgs>): Prisma.PrismaPromise<GetExerciseLogAggregateType<T>>

    /**
     * Group by ExerciseLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseLogGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExerciseLogClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    times<T extends ExerciseLog$timesArgs= {}>(args?: Subset<T, ExerciseLog$timesArgs>): Prisma.PrismaPromise<Array<ExerciseTimeGetPayload<T>>| Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    workoutLog<T extends WorkoutLogArgs= {}>(args?: Subset<T, WorkoutLogArgs>): Prisma__WorkoutLogClient<WorkoutLogGetPayload<T> | Null>;

    exercise<T extends ExerciseArgs= {}>(args?: Subset<T, ExerciseArgs>): Prisma__ExerciseClient<ExerciseGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ExerciseLog base type for findUnique actions
   */
  export type ExerciseLogFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where: ExerciseLogWhereUniqueInput
  }

  /**
   * ExerciseLog findUnique
   */
  export interface ExerciseLogFindUniqueArgs extends ExerciseLogFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ExerciseLog findUniqueOrThrow
   */
  export type ExerciseLogFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where: ExerciseLogWhereUniqueInput
  }


  /**
   * ExerciseLog base type for findFirst actions
   */
  export type ExerciseLogFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: Enumerable<ExerciseLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseLogs.
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseLogs.
     */
    distinct?: Enumerable<ExerciseLogScalarFieldEnum>
  }

  /**
   * ExerciseLog findFirst
   */
  export interface ExerciseLogFindFirstArgs extends ExerciseLogFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ExerciseLog findFirstOrThrow
   */
  export type ExerciseLogFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    /**
     * Filter, which ExerciseLog to fetch.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: Enumerable<ExerciseLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseLogs.
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseLogs.
     */
    distinct?: Enumerable<ExerciseLogScalarFieldEnum>
  }


  /**
   * ExerciseLog findMany
   */
  export type ExerciseLogFindManyArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    /**
     * Filter, which ExerciseLogs to fetch.
     */
    where?: ExerciseLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseLogs to fetch.
     */
    orderBy?: Enumerable<ExerciseLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseLogs.
     */
    cursor?: ExerciseLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseLogs.
     */
    skip?: number
    distinct?: Enumerable<ExerciseLogScalarFieldEnum>
  }


  /**
   * ExerciseLog create
   */
  export type ExerciseLogCreateArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    /**
     * The data needed to create a ExerciseLog.
     */
    data: XOR<ExerciseLogCreateInput, ExerciseLogUncheckedCreateInput>
  }


  /**
   * ExerciseLog createMany
   */
  export type ExerciseLogCreateManyArgs = {
    /**
     * The data used to create many ExerciseLogs.
     */
    data: Enumerable<ExerciseLogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ExerciseLog update
   */
  export type ExerciseLogUpdateArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    /**
     * The data needed to update a ExerciseLog.
     */
    data: XOR<ExerciseLogUpdateInput, ExerciseLogUncheckedUpdateInput>
    /**
     * Choose, which ExerciseLog to update.
     */
    where: ExerciseLogWhereUniqueInput
  }


  /**
   * ExerciseLog updateMany
   */
  export type ExerciseLogUpdateManyArgs = {
    /**
     * The data used to update ExerciseLogs.
     */
    data: XOR<ExerciseLogUpdateManyMutationInput, ExerciseLogUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseLogs to update
     */
    where?: ExerciseLogWhereInput
  }


  /**
   * ExerciseLog upsert
   */
  export type ExerciseLogUpsertArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    /**
     * The filter to search for the ExerciseLog to update in case it exists.
     */
    where: ExerciseLogWhereUniqueInput
    /**
     * In case the ExerciseLog found by the `where` argument doesn't exist, create a new ExerciseLog with this data.
     */
    create: XOR<ExerciseLogCreateInput, ExerciseLogUncheckedCreateInput>
    /**
     * In case the ExerciseLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseLogUpdateInput, ExerciseLogUncheckedUpdateInput>
  }


  /**
   * ExerciseLog delete
   */
  export type ExerciseLogDeleteArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    /**
     * Filter which ExerciseLog to delete.
     */
    where: ExerciseLogWhereUniqueInput
  }


  /**
   * ExerciseLog deleteMany
   */
  export type ExerciseLogDeleteManyArgs = {
    /**
     * Filter which ExerciseLogs to delete
     */
    where?: ExerciseLogWhereInput
  }


  /**
   * ExerciseLog.times
   */
  export type ExerciseLog$timesArgs = {
    /**
     * Select specific fields to fetch from the ExerciseTime
     */
    select?: ExerciseTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseTimeInclude | null
    where?: ExerciseTimeWhereInput
    orderBy?: Enumerable<ExerciseTimeOrderByWithRelationInput>
    cursor?: ExerciseTimeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ExerciseTimeScalarFieldEnum>
  }


  /**
   * ExerciseLog without action
   */
  export type ExerciseLogArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
  }



  /**
   * Model ExerciseTime
   */


  export type AggregateExerciseTime = {
    _count: ExerciseTimeCountAggregateOutputType | null
    _avg: ExerciseTimeAvgAggregateOutputType | null
    _sum: ExerciseTimeSumAggregateOutputType | null
    _min: ExerciseTimeMinAggregateOutputType | null
    _max: ExerciseTimeMaxAggregateOutputType | null
  }

  export type ExerciseTimeAvgAggregateOutputType = {
    id: number | null
    weight: number | null
    repeat: number | null
    exerciseLogId: number | null
  }

  export type ExerciseTimeSumAggregateOutputType = {
    id: number | null
    weight: number | null
    repeat: number | null
    exerciseLogId: number | null
  }

  export type ExerciseTimeMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    weight: number | null
    repeat: number | null
    isCompleted: boolean | null
    exerciseLogId: number | null
  }

  export type ExerciseTimeMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    weight: number | null
    repeat: number | null
    isCompleted: boolean | null
    exerciseLogId: number | null
  }

  export type ExerciseTimeCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    weight: number
    repeat: number
    isCompleted: number
    exerciseLogId: number
    _all: number
  }


  export type ExerciseTimeAvgAggregateInputType = {
    id?: true
    weight?: true
    repeat?: true
    exerciseLogId?: true
  }

  export type ExerciseTimeSumAggregateInputType = {
    id?: true
    weight?: true
    repeat?: true
    exerciseLogId?: true
  }

  export type ExerciseTimeMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    weight?: true
    repeat?: true
    isCompleted?: true
    exerciseLogId?: true
  }

  export type ExerciseTimeMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    weight?: true
    repeat?: true
    isCompleted?: true
    exerciseLogId?: true
  }

  export type ExerciseTimeCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    weight?: true
    repeat?: true
    isCompleted?: true
    exerciseLogId?: true
    _all?: true
  }

  export type ExerciseTimeAggregateArgs = {
    /**
     * Filter which ExerciseTime to aggregate.
     */
    where?: ExerciseTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTimes to fetch.
     */
    orderBy?: Enumerable<ExerciseTimeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExerciseTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExerciseTimes
    **/
    _count?: true | ExerciseTimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExerciseTimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExerciseTimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExerciseTimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExerciseTimeMaxAggregateInputType
  }

  export type GetExerciseTimeAggregateType<T extends ExerciseTimeAggregateArgs> = {
        [P in keyof T & keyof AggregateExerciseTime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExerciseTime[P]>
      : GetScalarType<T[P], AggregateExerciseTime[P]>
  }




  export type ExerciseTimeGroupByArgs = {
    where?: ExerciseTimeWhereInput
    orderBy?: Enumerable<ExerciseTimeOrderByWithAggregationInput>
    by: ExerciseTimeScalarFieldEnum[]
    having?: ExerciseTimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExerciseTimeCountAggregateInputType | true
    _avg?: ExerciseTimeAvgAggregateInputType
    _sum?: ExerciseTimeSumAggregateInputType
    _min?: ExerciseTimeMinAggregateInputType
    _max?: ExerciseTimeMaxAggregateInputType
  }


  export type ExerciseTimeGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    weight: number
    repeat: number
    isCompleted: boolean
    exerciseLogId: number | null
    _count: ExerciseTimeCountAggregateOutputType | null
    _avg: ExerciseTimeAvgAggregateOutputType | null
    _sum: ExerciseTimeSumAggregateOutputType | null
    _min: ExerciseTimeMinAggregateOutputType | null
    _max: ExerciseTimeMaxAggregateOutputType | null
  }

  type GetExerciseTimeGroupByPayload<T extends ExerciseTimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ExerciseTimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExerciseTimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExerciseTimeGroupByOutputType[P]>
            : GetScalarType<T[P], ExerciseTimeGroupByOutputType[P]>
        }
      >
    >


  export type ExerciseTimeSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    weight?: boolean
    repeat?: boolean
    isCompleted?: boolean
    exerciseLogId?: boolean
    exerciseLog?: boolean | ExerciseLogArgs
  }


  export type ExerciseTimeInclude = {
    exerciseLog?: boolean | ExerciseLogArgs
  }

  export type ExerciseTimeGetPayload<S extends boolean | null | undefined | ExerciseTimeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? ExerciseTime :
    S extends undefined ? never :
    S extends { include: any } & (ExerciseTimeArgs | ExerciseTimeFindManyArgs)
    ? ExerciseTime  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'exerciseLog' ? ExerciseLogGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (ExerciseTimeArgs | ExerciseTimeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'exerciseLog' ? ExerciseLogGetPayload<S['select'][P]> | null :  P extends keyof ExerciseTime ? ExerciseTime[P] : never
  } 
      : ExerciseTime


  type ExerciseTimeCountArgs = 
    Omit<ExerciseTimeFindManyArgs, 'select' | 'include'> & {
      select?: ExerciseTimeCountAggregateInputType | true
    }

  export interface ExerciseTimeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one ExerciseTime that matches the filter.
     * @param {ExerciseTimeFindUniqueArgs} args - Arguments to find a ExerciseTime
     * @example
     * // Get one ExerciseTime
     * const exerciseTime = await prisma.exerciseTime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ExerciseTimeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ExerciseTimeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'ExerciseTime'> extends True ? Prisma__ExerciseTimeClient<ExerciseTimeGetPayload<T>> : Prisma__ExerciseTimeClient<ExerciseTimeGetPayload<T> | null, null>

    /**
     * Find one ExerciseTime that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ExerciseTimeFindUniqueOrThrowArgs} args - Arguments to find a ExerciseTime
     * @example
     * // Get one ExerciseTime
     * const exerciseTime = await prisma.exerciseTime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ExerciseTimeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, ExerciseTimeFindUniqueOrThrowArgs>
    ): Prisma__ExerciseTimeClient<ExerciseTimeGetPayload<T>>

    /**
     * Find the first ExerciseTime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTimeFindFirstArgs} args - Arguments to find a ExerciseTime
     * @example
     * // Get one ExerciseTime
     * const exerciseTime = await prisma.exerciseTime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ExerciseTimeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ExerciseTimeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'ExerciseTime'> extends True ? Prisma__ExerciseTimeClient<ExerciseTimeGetPayload<T>> : Prisma__ExerciseTimeClient<ExerciseTimeGetPayload<T> | null, null>

    /**
     * Find the first ExerciseTime that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTimeFindFirstOrThrowArgs} args - Arguments to find a ExerciseTime
     * @example
     * // Get one ExerciseTime
     * const exerciseTime = await prisma.exerciseTime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ExerciseTimeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ExerciseTimeFindFirstOrThrowArgs>
    ): Prisma__ExerciseTimeClient<ExerciseTimeGetPayload<T>>

    /**
     * Find zero or more ExerciseTimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTimeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExerciseTimes
     * const exerciseTimes = await prisma.exerciseTime.findMany()
     * 
     * // Get first 10 ExerciseTimes
     * const exerciseTimes = await prisma.exerciseTime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exerciseTimeWithIdOnly = await prisma.exerciseTime.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ExerciseTimeFindManyArgs>(
      args?: SelectSubset<T, ExerciseTimeFindManyArgs>
    ): Prisma.PrismaPromise<Array<ExerciseTimeGetPayload<T>>>

    /**
     * Create a ExerciseTime.
     * @param {ExerciseTimeCreateArgs} args - Arguments to create a ExerciseTime.
     * @example
     * // Create one ExerciseTime
     * const ExerciseTime = await prisma.exerciseTime.create({
     *   data: {
     *     // ... data to create a ExerciseTime
     *   }
     * })
     * 
    **/
    create<T extends ExerciseTimeCreateArgs>(
      args: SelectSubset<T, ExerciseTimeCreateArgs>
    ): Prisma__ExerciseTimeClient<ExerciseTimeGetPayload<T>>

    /**
     * Create many ExerciseTimes.
     *     @param {ExerciseTimeCreateManyArgs} args - Arguments to create many ExerciseTimes.
     *     @example
     *     // Create many ExerciseTimes
     *     const exerciseTime = await prisma.exerciseTime.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ExerciseTimeCreateManyArgs>(
      args?: SelectSubset<T, ExerciseTimeCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ExerciseTime.
     * @param {ExerciseTimeDeleteArgs} args - Arguments to delete one ExerciseTime.
     * @example
     * // Delete one ExerciseTime
     * const ExerciseTime = await prisma.exerciseTime.delete({
     *   where: {
     *     // ... filter to delete one ExerciseTime
     *   }
     * })
     * 
    **/
    delete<T extends ExerciseTimeDeleteArgs>(
      args: SelectSubset<T, ExerciseTimeDeleteArgs>
    ): Prisma__ExerciseTimeClient<ExerciseTimeGetPayload<T>>

    /**
     * Update one ExerciseTime.
     * @param {ExerciseTimeUpdateArgs} args - Arguments to update one ExerciseTime.
     * @example
     * // Update one ExerciseTime
     * const exerciseTime = await prisma.exerciseTime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ExerciseTimeUpdateArgs>(
      args: SelectSubset<T, ExerciseTimeUpdateArgs>
    ): Prisma__ExerciseTimeClient<ExerciseTimeGetPayload<T>>

    /**
     * Delete zero or more ExerciseTimes.
     * @param {ExerciseTimeDeleteManyArgs} args - Arguments to filter ExerciseTimes to delete.
     * @example
     * // Delete a few ExerciseTimes
     * const { count } = await prisma.exerciseTime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ExerciseTimeDeleteManyArgs>(
      args?: SelectSubset<T, ExerciseTimeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExerciseTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExerciseTimes
     * const exerciseTime = await prisma.exerciseTime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ExerciseTimeUpdateManyArgs>(
      args: SelectSubset<T, ExerciseTimeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExerciseTime.
     * @param {ExerciseTimeUpsertArgs} args - Arguments to update or create a ExerciseTime.
     * @example
     * // Update or create a ExerciseTime
     * const exerciseTime = await prisma.exerciseTime.upsert({
     *   create: {
     *     // ... data to create a ExerciseTime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExerciseTime we want to update
     *   }
     * })
    **/
    upsert<T extends ExerciseTimeUpsertArgs>(
      args: SelectSubset<T, ExerciseTimeUpsertArgs>
    ): Prisma__ExerciseTimeClient<ExerciseTimeGetPayload<T>>

    /**
     * Count the number of ExerciseTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTimeCountArgs} args - Arguments to filter ExerciseTimes to count.
     * @example
     * // Count the number of ExerciseTimes
     * const count = await prisma.exerciseTime.count({
     *   where: {
     *     // ... the filter for the ExerciseTimes we want to count
     *   }
     * })
    **/
    count<T extends ExerciseTimeCountArgs>(
      args?: Subset<T, ExerciseTimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExerciseTimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExerciseTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExerciseTimeAggregateArgs>(args: Subset<T, ExerciseTimeAggregateArgs>): Prisma.PrismaPromise<GetExerciseTimeAggregateType<T>>

    /**
     * Group by ExerciseTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExerciseTimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExerciseTimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExerciseTimeGroupByArgs['orderBy'] }
        : { orderBy?: ExerciseTimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExerciseTimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExerciseTimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for ExerciseTime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ExerciseTimeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    exerciseLog<T extends ExerciseLogArgs= {}>(args?: Subset<T, ExerciseLogArgs>): Prisma__ExerciseLogClient<ExerciseLogGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * ExerciseTime base type for findUnique actions
   */
  export type ExerciseTimeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the ExerciseTime
     */
    select?: ExerciseTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseTimeInclude | null
    /**
     * Filter, which ExerciseTime to fetch.
     */
    where: ExerciseTimeWhereUniqueInput
  }

  /**
   * ExerciseTime findUnique
   */
  export interface ExerciseTimeFindUniqueArgs extends ExerciseTimeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ExerciseTime findUniqueOrThrow
   */
  export type ExerciseTimeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ExerciseTime
     */
    select?: ExerciseTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseTimeInclude | null
    /**
     * Filter, which ExerciseTime to fetch.
     */
    where: ExerciseTimeWhereUniqueInput
  }


  /**
   * ExerciseTime base type for findFirst actions
   */
  export type ExerciseTimeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the ExerciseTime
     */
    select?: ExerciseTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseTimeInclude | null
    /**
     * Filter, which ExerciseTime to fetch.
     */
    where?: ExerciseTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTimes to fetch.
     */
    orderBy?: Enumerable<ExerciseTimeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseTimes.
     */
    cursor?: ExerciseTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseTimes.
     */
    distinct?: Enumerable<ExerciseTimeScalarFieldEnum>
  }

  /**
   * ExerciseTime findFirst
   */
  export interface ExerciseTimeFindFirstArgs extends ExerciseTimeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * ExerciseTime findFirstOrThrow
   */
  export type ExerciseTimeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the ExerciseTime
     */
    select?: ExerciseTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseTimeInclude | null
    /**
     * Filter, which ExerciseTime to fetch.
     */
    where?: ExerciseTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTimes to fetch.
     */
    orderBy?: Enumerable<ExerciseTimeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExerciseTimes.
     */
    cursor?: ExerciseTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExerciseTimes.
     */
    distinct?: Enumerable<ExerciseTimeScalarFieldEnum>
  }


  /**
   * ExerciseTime findMany
   */
  export type ExerciseTimeFindManyArgs = {
    /**
     * Select specific fields to fetch from the ExerciseTime
     */
    select?: ExerciseTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseTimeInclude | null
    /**
     * Filter, which ExerciseTimes to fetch.
     */
    where?: ExerciseTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExerciseTimes to fetch.
     */
    orderBy?: Enumerable<ExerciseTimeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExerciseTimes.
     */
    cursor?: ExerciseTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExerciseTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExerciseTimes.
     */
    skip?: number
    distinct?: Enumerable<ExerciseTimeScalarFieldEnum>
  }


  /**
   * ExerciseTime create
   */
  export type ExerciseTimeCreateArgs = {
    /**
     * Select specific fields to fetch from the ExerciseTime
     */
    select?: ExerciseTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseTimeInclude | null
    /**
     * The data needed to create a ExerciseTime.
     */
    data: XOR<ExerciseTimeCreateInput, ExerciseTimeUncheckedCreateInput>
  }


  /**
   * ExerciseTime createMany
   */
  export type ExerciseTimeCreateManyArgs = {
    /**
     * The data used to create many ExerciseTimes.
     */
    data: Enumerable<ExerciseTimeCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * ExerciseTime update
   */
  export type ExerciseTimeUpdateArgs = {
    /**
     * Select specific fields to fetch from the ExerciseTime
     */
    select?: ExerciseTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseTimeInclude | null
    /**
     * The data needed to update a ExerciseTime.
     */
    data: XOR<ExerciseTimeUpdateInput, ExerciseTimeUncheckedUpdateInput>
    /**
     * Choose, which ExerciseTime to update.
     */
    where: ExerciseTimeWhereUniqueInput
  }


  /**
   * ExerciseTime updateMany
   */
  export type ExerciseTimeUpdateManyArgs = {
    /**
     * The data used to update ExerciseTimes.
     */
    data: XOR<ExerciseTimeUpdateManyMutationInput, ExerciseTimeUncheckedUpdateManyInput>
    /**
     * Filter which ExerciseTimes to update
     */
    where?: ExerciseTimeWhereInput
  }


  /**
   * ExerciseTime upsert
   */
  export type ExerciseTimeUpsertArgs = {
    /**
     * Select specific fields to fetch from the ExerciseTime
     */
    select?: ExerciseTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseTimeInclude | null
    /**
     * The filter to search for the ExerciseTime to update in case it exists.
     */
    where: ExerciseTimeWhereUniqueInput
    /**
     * In case the ExerciseTime found by the `where` argument doesn't exist, create a new ExerciseTime with this data.
     */
    create: XOR<ExerciseTimeCreateInput, ExerciseTimeUncheckedCreateInput>
    /**
     * In case the ExerciseTime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExerciseTimeUpdateInput, ExerciseTimeUncheckedUpdateInput>
  }


  /**
   * ExerciseTime delete
   */
  export type ExerciseTimeDeleteArgs = {
    /**
     * Select specific fields to fetch from the ExerciseTime
     */
    select?: ExerciseTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseTimeInclude | null
    /**
     * Filter which ExerciseTime to delete.
     */
    where: ExerciseTimeWhereUniqueInput
  }


  /**
   * ExerciseTime deleteMany
   */
  export type ExerciseTimeDeleteManyArgs = {
    /**
     * Filter which ExerciseTimes to delete
     */
    where?: ExerciseTimeWhereInput
  }


  /**
   * ExerciseTime without action
   */
  export type ExerciseTimeArgs = {
    /**
     * Select specific fields to fetch from the ExerciseTime
     */
    select?: ExerciseTimeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseTimeInclude | null
  }



  /**
   * Model WorkoutLog
   */


  export type AggregateWorkoutLog = {
    _count: WorkoutLogCountAggregateOutputType | null
    _avg: WorkoutLogAvgAggregateOutputType | null
    _sum: WorkoutLogSumAggregateOutputType | null
    _min: WorkoutLogMinAggregateOutputType | null
    _max: WorkoutLogMaxAggregateOutputType | null
  }

  export type WorkoutLogAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    workoutId: number | null
  }

  export type WorkoutLogSumAggregateOutputType = {
    id: number | null
    userId: number | null
    workoutId: number | null
  }

  export type WorkoutLogMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isCompleted: boolean | null
    userId: number | null
    workoutId: number | null
  }

  export type WorkoutLogMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    updatedAt: Date | null
    isCompleted: boolean | null
    userId: number | null
    workoutId: number | null
  }

  export type WorkoutLogCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    isCompleted: number
    userId: number
    workoutId: number
    _all: number
  }


  export type WorkoutLogAvgAggregateInputType = {
    id?: true
    userId?: true
    workoutId?: true
  }

  export type WorkoutLogSumAggregateInputType = {
    id?: true
    userId?: true
    workoutId?: true
  }

  export type WorkoutLogMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isCompleted?: true
    userId?: true
    workoutId?: true
  }

  export type WorkoutLogMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isCompleted?: true
    userId?: true
    workoutId?: true
  }

  export type WorkoutLogCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    isCompleted?: true
    userId?: true
    workoutId?: true
    _all?: true
  }

  export type WorkoutLogAggregateArgs = {
    /**
     * Filter which WorkoutLog to aggregate.
     */
    where?: WorkoutLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutLogs to fetch.
     */
    orderBy?: Enumerable<WorkoutLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkoutLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkoutLogs
    **/
    _count?: true | WorkoutLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkoutLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkoutLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkoutLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkoutLogMaxAggregateInputType
  }

  export type GetWorkoutLogAggregateType<T extends WorkoutLogAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkoutLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkoutLog[P]>
      : GetScalarType<T[P], AggregateWorkoutLog[P]>
  }




  export type WorkoutLogGroupByArgs = {
    where?: WorkoutLogWhereInput
    orderBy?: Enumerable<WorkoutLogOrderByWithAggregationInput>
    by: WorkoutLogScalarFieldEnum[]
    having?: WorkoutLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkoutLogCountAggregateInputType | true
    _avg?: WorkoutLogAvgAggregateInputType
    _sum?: WorkoutLogSumAggregateInputType
    _min?: WorkoutLogMinAggregateInputType
    _max?: WorkoutLogMaxAggregateInputType
  }


  export type WorkoutLogGroupByOutputType = {
    id: number
    createdAt: Date
    updatedAt: Date
    isCompleted: boolean
    userId: number | null
    workoutId: number | null
    _count: WorkoutLogCountAggregateOutputType | null
    _avg: WorkoutLogAvgAggregateOutputType | null
    _sum: WorkoutLogSumAggregateOutputType | null
    _min: WorkoutLogMinAggregateOutputType | null
    _max: WorkoutLogMaxAggregateOutputType | null
  }

  type GetWorkoutLogGroupByPayload<T extends WorkoutLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<WorkoutLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkoutLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkoutLogGroupByOutputType[P]>
            : GetScalarType<T[P], WorkoutLogGroupByOutputType[P]>
        }
      >
    >


  export type WorkoutLogSelect = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isCompleted?: boolean
    userId?: boolean
    workoutId?: boolean
    exerciseLogs?: boolean | WorkoutLog$exerciseLogsArgs
    user?: boolean | UserArgs
    workout?: boolean | WorkoutArgs
    _count?: boolean | WorkoutLogCountOutputTypeArgs
  }


  export type WorkoutLogInclude = {
    exerciseLogs?: boolean | WorkoutLog$exerciseLogsArgs
    user?: boolean | UserArgs
    workout?: boolean | WorkoutArgs
    _count?: boolean | WorkoutLogCountOutputTypeArgs
  }

  export type WorkoutLogGetPayload<S extends boolean | null | undefined | WorkoutLogArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? WorkoutLog :
    S extends undefined ? never :
    S extends { include: any } & (WorkoutLogArgs | WorkoutLogFindManyArgs)
    ? WorkoutLog  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'exerciseLogs' ? Array < ExerciseLogGetPayload<S['include'][P]>>  :
        P extends 'user' ? UserGetPayload<S['include'][P]> | null :
        P extends 'workout' ? WorkoutGetPayload<S['include'][P]> | null :
        P extends '_count' ? WorkoutLogCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (WorkoutLogArgs | WorkoutLogFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'exerciseLogs' ? Array < ExerciseLogGetPayload<S['select'][P]>>  :
        P extends 'user' ? UserGetPayload<S['select'][P]> | null :
        P extends 'workout' ? WorkoutGetPayload<S['select'][P]> | null :
        P extends '_count' ? WorkoutLogCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof WorkoutLog ? WorkoutLog[P] : never
  } 
      : WorkoutLog


  type WorkoutLogCountArgs = 
    Omit<WorkoutLogFindManyArgs, 'select' | 'include'> & {
      select?: WorkoutLogCountAggregateInputType | true
    }

  export interface WorkoutLogDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one WorkoutLog that matches the filter.
     * @param {WorkoutLogFindUniqueArgs} args - Arguments to find a WorkoutLog
     * @example
     * // Get one WorkoutLog
     * const workoutLog = await prisma.workoutLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WorkoutLogFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WorkoutLogFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'WorkoutLog'> extends True ? Prisma__WorkoutLogClient<WorkoutLogGetPayload<T>> : Prisma__WorkoutLogClient<WorkoutLogGetPayload<T> | null, null>

    /**
     * Find one WorkoutLog that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {WorkoutLogFindUniqueOrThrowArgs} args - Arguments to find a WorkoutLog
     * @example
     * // Get one WorkoutLog
     * const workoutLog = await prisma.workoutLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends WorkoutLogFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, WorkoutLogFindUniqueOrThrowArgs>
    ): Prisma__WorkoutLogClient<WorkoutLogGetPayload<T>>

    /**
     * Find the first WorkoutLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogFindFirstArgs} args - Arguments to find a WorkoutLog
     * @example
     * // Get one WorkoutLog
     * const workoutLog = await prisma.workoutLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WorkoutLogFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WorkoutLogFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'WorkoutLog'> extends True ? Prisma__WorkoutLogClient<WorkoutLogGetPayload<T>> : Prisma__WorkoutLogClient<WorkoutLogGetPayload<T> | null, null>

    /**
     * Find the first WorkoutLog that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogFindFirstOrThrowArgs} args - Arguments to find a WorkoutLog
     * @example
     * // Get one WorkoutLog
     * const workoutLog = await prisma.workoutLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends WorkoutLogFindFirstOrThrowArgs>(
      args?: SelectSubset<T, WorkoutLogFindFirstOrThrowArgs>
    ): Prisma__WorkoutLogClient<WorkoutLogGetPayload<T>>

    /**
     * Find zero or more WorkoutLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkoutLogs
     * const workoutLogs = await prisma.workoutLog.findMany()
     * 
     * // Get first 10 WorkoutLogs
     * const workoutLogs = await prisma.workoutLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workoutLogWithIdOnly = await prisma.workoutLog.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WorkoutLogFindManyArgs>(
      args?: SelectSubset<T, WorkoutLogFindManyArgs>
    ): Prisma.PrismaPromise<Array<WorkoutLogGetPayload<T>>>

    /**
     * Create a WorkoutLog.
     * @param {WorkoutLogCreateArgs} args - Arguments to create a WorkoutLog.
     * @example
     * // Create one WorkoutLog
     * const WorkoutLog = await prisma.workoutLog.create({
     *   data: {
     *     // ... data to create a WorkoutLog
     *   }
     * })
     * 
    **/
    create<T extends WorkoutLogCreateArgs>(
      args: SelectSubset<T, WorkoutLogCreateArgs>
    ): Prisma__WorkoutLogClient<WorkoutLogGetPayload<T>>

    /**
     * Create many WorkoutLogs.
     *     @param {WorkoutLogCreateManyArgs} args - Arguments to create many WorkoutLogs.
     *     @example
     *     // Create many WorkoutLogs
     *     const workoutLog = await prisma.workoutLog.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WorkoutLogCreateManyArgs>(
      args?: SelectSubset<T, WorkoutLogCreateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkoutLog.
     * @param {WorkoutLogDeleteArgs} args - Arguments to delete one WorkoutLog.
     * @example
     * // Delete one WorkoutLog
     * const WorkoutLog = await prisma.workoutLog.delete({
     *   where: {
     *     // ... filter to delete one WorkoutLog
     *   }
     * })
     * 
    **/
    delete<T extends WorkoutLogDeleteArgs>(
      args: SelectSubset<T, WorkoutLogDeleteArgs>
    ): Prisma__WorkoutLogClient<WorkoutLogGetPayload<T>>

    /**
     * Update one WorkoutLog.
     * @param {WorkoutLogUpdateArgs} args - Arguments to update one WorkoutLog.
     * @example
     * // Update one WorkoutLog
     * const workoutLog = await prisma.workoutLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WorkoutLogUpdateArgs>(
      args: SelectSubset<T, WorkoutLogUpdateArgs>
    ): Prisma__WorkoutLogClient<WorkoutLogGetPayload<T>>

    /**
     * Delete zero or more WorkoutLogs.
     * @param {WorkoutLogDeleteManyArgs} args - Arguments to filter WorkoutLogs to delete.
     * @example
     * // Delete a few WorkoutLogs
     * const { count } = await prisma.workoutLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WorkoutLogDeleteManyArgs>(
      args?: SelectSubset<T, WorkoutLogDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkoutLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkoutLogs
     * const workoutLog = await prisma.workoutLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WorkoutLogUpdateManyArgs>(
      args: SelectSubset<T, WorkoutLogUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkoutLog.
     * @param {WorkoutLogUpsertArgs} args - Arguments to update or create a WorkoutLog.
     * @example
     * // Update or create a WorkoutLog
     * const workoutLog = await prisma.workoutLog.upsert({
     *   create: {
     *     // ... data to create a WorkoutLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkoutLog we want to update
     *   }
     * })
    **/
    upsert<T extends WorkoutLogUpsertArgs>(
      args: SelectSubset<T, WorkoutLogUpsertArgs>
    ): Prisma__WorkoutLogClient<WorkoutLogGetPayload<T>>

    /**
     * Count the number of WorkoutLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogCountArgs} args - Arguments to filter WorkoutLogs to count.
     * @example
     * // Count the number of WorkoutLogs
     * const count = await prisma.workoutLog.count({
     *   where: {
     *     // ... the filter for the WorkoutLogs we want to count
     *   }
     * })
    **/
    count<T extends WorkoutLogCountArgs>(
      args?: Subset<T, WorkoutLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkoutLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkoutLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkoutLogAggregateArgs>(args: Subset<T, WorkoutLogAggregateArgs>): Prisma.PrismaPromise<GetWorkoutLogAggregateType<T>>

    /**
     * Group by WorkoutLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkoutLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkoutLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkoutLogGroupByArgs['orderBy'] }
        : { orderBy?: WorkoutLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkoutLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkoutLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkoutLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WorkoutLogClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    exerciseLogs<T extends WorkoutLog$exerciseLogsArgs= {}>(args?: Subset<T, WorkoutLog$exerciseLogsArgs>): Prisma.PrismaPromise<Array<ExerciseLogGetPayload<T>>| Null>;

    user<T extends UserArgs= {}>(args?: Subset<T, UserArgs>): Prisma__UserClient<UserGetPayload<T> | Null>;

    workout<T extends WorkoutArgs= {}>(args?: Subset<T, WorkoutArgs>): Prisma__WorkoutClient<WorkoutGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * WorkoutLog base type for findUnique actions
   */
  export type WorkoutLogFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
    /**
     * Filter, which WorkoutLog to fetch.
     */
    where: WorkoutLogWhereUniqueInput
  }

  /**
   * WorkoutLog findUnique
   */
  export interface WorkoutLogFindUniqueArgs extends WorkoutLogFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WorkoutLog findUniqueOrThrow
   */
  export type WorkoutLogFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
    /**
     * Filter, which WorkoutLog to fetch.
     */
    where: WorkoutLogWhereUniqueInput
  }


  /**
   * WorkoutLog base type for findFirst actions
   */
  export type WorkoutLogFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
    /**
     * Filter, which WorkoutLog to fetch.
     */
    where?: WorkoutLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutLogs to fetch.
     */
    orderBy?: Enumerable<WorkoutLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutLogs.
     */
    cursor?: WorkoutLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutLogs.
     */
    distinct?: Enumerable<WorkoutLogScalarFieldEnum>
  }

  /**
   * WorkoutLog findFirst
   */
  export interface WorkoutLogFindFirstArgs extends WorkoutLogFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * WorkoutLog findFirstOrThrow
   */
  export type WorkoutLogFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
    /**
     * Filter, which WorkoutLog to fetch.
     */
    where?: WorkoutLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutLogs to fetch.
     */
    orderBy?: Enumerable<WorkoutLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkoutLogs.
     */
    cursor?: WorkoutLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkoutLogs.
     */
    distinct?: Enumerable<WorkoutLogScalarFieldEnum>
  }


  /**
   * WorkoutLog findMany
   */
  export type WorkoutLogFindManyArgs = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
    /**
     * Filter, which WorkoutLogs to fetch.
     */
    where?: WorkoutLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkoutLogs to fetch.
     */
    orderBy?: Enumerable<WorkoutLogOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkoutLogs.
     */
    cursor?: WorkoutLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkoutLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkoutLogs.
     */
    skip?: number
    distinct?: Enumerable<WorkoutLogScalarFieldEnum>
  }


  /**
   * WorkoutLog create
   */
  export type WorkoutLogCreateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
    /**
     * The data needed to create a WorkoutLog.
     */
    data: XOR<WorkoutLogCreateInput, WorkoutLogUncheckedCreateInput>
  }


  /**
   * WorkoutLog createMany
   */
  export type WorkoutLogCreateManyArgs = {
    /**
     * The data used to create many WorkoutLogs.
     */
    data: Enumerable<WorkoutLogCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * WorkoutLog update
   */
  export type WorkoutLogUpdateArgs = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
    /**
     * The data needed to update a WorkoutLog.
     */
    data: XOR<WorkoutLogUpdateInput, WorkoutLogUncheckedUpdateInput>
    /**
     * Choose, which WorkoutLog to update.
     */
    where: WorkoutLogWhereUniqueInput
  }


  /**
   * WorkoutLog updateMany
   */
  export type WorkoutLogUpdateManyArgs = {
    /**
     * The data used to update WorkoutLogs.
     */
    data: XOR<WorkoutLogUpdateManyMutationInput, WorkoutLogUncheckedUpdateManyInput>
    /**
     * Filter which WorkoutLogs to update
     */
    where?: WorkoutLogWhereInput
  }


  /**
   * WorkoutLog upsert
   */
  export type WorkoutLogUpsertArgs = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
    /**
     * The filter to search for the WorkoutLog to update in case it exists.
     */
    where: WorkoutLogWhereUniqueInput
    /**
     * In case the WorkoutLog found by the `where` argument doesn't exist, create a new WorkoutLog with this data.
     */
    create: XOR<WorkoutLogCreateInput, WorkoutLogUncheckedCreateInput>
    /**
     * In case the WorkoutLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkoutLogUpdateInput, WorkoutLogUncheckedUpdateInput>
  }


  /**
   * WorkoutLog delete
   */
  export type WorkoutLogDeleteArgs = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
    /**
     * Filter which WorkoutLog to delete.
     */
    where: WorkoutLogWhereUniqueInput
  }


  /**
   * WorkoutLog deleteMany
   */
  export type WorkoutLogDeleteManyArgs = {
    /**
     * Filter which WorkoutLogs to delete
     */
    where?: WorkoutLogWhereInput
  }


  /**
   * WorkoutLog.exerciseLogs
   */
  export type WorkoutLog$exerciseLogsArgs = {
    /**
     * Select specific fields to fetch from the ExerciseLog
     */
    select?: ExerciseLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ExerciseLogInclude | null
    where?: ExerciseLogWhereInput
    orderBy?: Enumerable<ExerciseLogOrderByWithRelationInput>
    cursor?: ExerciseLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ExerciseLogScalarFieldEnum>
  }


  /**
   * WorkoutLog without action
   */
  export type WorkoutLogArgs = {
    /**
     * Select specific fields to fetch from the WorkoutLog
     */
    select?: WorkoutLogSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: WorkoutLogInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ExerciseLogScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isCompleted: 'isCompleted',
    userId: 'userId',
    workoutLogId: 'workoutLogId',
    exerciseId: 'exerciseId'
  };

  export type ExerciseLogScalarFieldEnum = (typeof ExerciseLogScalarFieldEnum)[keyof typeof ExerciseLogScalarFieldEnum]


  export const ExerciseScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name',
    times: 'times',
    iconPath: 'iconPath'
  };

  export type ExerciseScalarFieldEnum = (typeof ExerciseScalarFieldEnum)[keyof typeof ExerciseScalarFieldEnum]


  export const ExerciseTimeScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    weight: 'weight',
    repeat: 'repeat',
    isCompleted: 'isCompleted',
    exerciseLogId: 'exerciseLogId'
  };

  export type ExerciseTimeScalarFieldEnum = (typeof ExerciseTimeScalarFieldEnum)[keyof typeof ExerciseTimeScalarFieldEnum]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    email: 'email',
    name: 'name',
    password: 'password',
    images: 'images'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WorkoutLogScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isCompleted: 'isCompleted',
    userId: 'userId',
    workoutId: 'workoutId'
  };

  export type WorkoutLogScalarFieldEnum = (typeof WorkoutLogScalarFieldEnum)[keyof typeof WorkoutLogScalarFieldEnum]


  export const WorkoutScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    name: 'name'
  };

  export type WorkoutScalarFieldEnum = (typeof WorkoutScalarFieldEnum)[keyof typeof WorkoutScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: Enumerable<UserWhereInput>
    OR?: Enumerable<UserWhereInput>
    NOT?: Enumerable<UserWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    email?: StringFilter | string
    name?: StringFilter | string
    password?: StringFilter | string
    images?: StringNullableListFilter
    exerciseLogs?: ExerciseLogListRelationFilter
    workoutLogs?: WorkoutLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    images?: SortOrder
    exerciseLogs?: ExerciseLogOrderByRelationAggregateInput
    workoutLogs?: WorkoutLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = {
    id?: number
    email?: string
  }

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    images?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UserScalarWhereWithAggregatesInput>
    OR?: Enumerable<UserScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UserScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    email?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    images?: StringNullableListFilter
  }

  export type WorkoutWhereInput = {
    AND?: Enumerable<WorkoutWhereInput>
    OR?: Enumerable<WorkoutWhereInput>
    NOT?: Enumerable<WorkoutWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    exercises?: ExerciseListRelationFilter
    workoutLogs?: WorkoutLogListRelationFilter
  }

  export type WorkoutOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    exercises?: ExerciseOrderByRelationAggregateInput
    workoutLogs?: WorkoutLogOrderByRelationAggregateInput
  }

  export type WorkoutWhereUniqueInput = {
    id?: number
  }

  export type WorkoutOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    _count?: WorkoutCountOrderByAggregateInput
    _avg?: WorkoutAvgOrderByAggregateInput
    _max?: WorkoutMaxOrderByAggregateInput
    _min?: WorkoutMinOrderByAggregateInput
    _sum?: WorkoutSumOrderByAggregateInput
  }

  export type WorkoutScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkoutScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkoutScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkoutScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
  }

  export type ExerciseWhereInput = {
    AND?: Enumerable<ExerciseWhereInput>
    OR?: Enumerable<ExerciseWhereInput>
    NOT?: Enumerable<ExerciseWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    times?: IntFilter | number
    iconPath?: StringFilter | string
    workouts?: WorkoutListRelationFilter
    exerciseLog?: ExerciseLogListRelationFilter
  }

  export type ExerciseOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    times?: SortOrder
    iconPath?: SortOrder
    workouts?: WorkoutOrderByRelationAggregateInput
    exerciseLog?: ExerciseLogOrderByRelationAggregateInput
  }

  export type ExerciseWhereUniqueInput = {
    id?: number
  }

  export type ExerciseOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    times?: SortOrder
    iconPath?: SortOrder
    _count?: ExerciseCountOrderByAggregateInput
    _avg?: ExerciseAvgOrderByAggregateInput
    _max?: ExerciseMaxOrderByAggregateInput
    _min?: ExerciseMinOrderByAggregateInput
    _sum?: ExerciseSumOrderByAggregateInput
  }

  export type ExerciseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExerciseScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExerciseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExerciseScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    times?: IntWithAggregatesFilter | number
    iconPath?: StringWithAggregatesFilter | string
  }

  export type ExerciseLogWhereInput = {
    AND?: Enumerable<ExerciseLogWhereInput>
    OR?: Enumerable<ExerciseLogWhereInput>
    NOT?: Enumerable<ExerciseLogWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isCompleted?: BoolFilter | boolean
    userId?: IntNullableFilter | number | null
    workoutLogId?: IntNullableFilter | number | null
    exerciseId?: IntNullableFilter | number | null
    times?: ExerciseTimeListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    workoutLog?: XOR<WorkoutLogRelationFilter, WorkoutLogWhereInput> | null
    exercise?: XOR<ExerciseRelationFilter, ExerciseWhereInput> | null
  }

  export type ExerciseLogOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCompleted?: SortOrder
    userId?: SortOrder
    workoutLogId?: SortOrder
    exerciseId?: SortOrder
    times?: ExerciseTimeOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    workoutLog?: WorkoutLogOrderByWithRelationInput
    exercise?: ExerciseOrderByWithRelationInput
  }

  export type ExerciseLogWhereUniqueInput = {
    id?: number
  }

  export type ExerciseLogOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCompleted?: SortOrder
    userId?: SortOrder
    workoutLogId?: SortOrder
    exerciseId?: SortOrder
    _count?: ExerciseLogCountOrderByAggregateInput
    _avg?: ExerciseLogAvgOrderByAggregateInput
    _max?: ExerciseLogMaxOrderByAggregateInput
    _min?: ExerciseLogMinOrderByAggregateInput
    _sum?: ExerciseLogSumOrderByAggregateInput
  }

  export type ExerciseLogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExerciseLogScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExerciseLogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExerciseLogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isCompleted?: BoolWithAggregatesFilter | boolean
    userId?: IntNullableWithAggregatesFilter | number | null
    workoutLogId?: IntNullableWithAggregatesFilter | number | null
    exerciseId?: IntNullableWithAggregatesFilter | number | null
  }

  export type ExerciseTimeWhereInput = {
    AND?: Enumerable<ExerciseTimeWhereInput>
    OR?: Enumerable<ExerciseTimeWhereInput>
    NOT?: Enumerable<ExerciseTimeWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    weight?: IntFilter | number
    repeat?: IntFilter | number
    isCompleted?: BoolFilter | boolean
    exerciseLogId?: IntNullableFilter | number | null
    exerciseLog?: XOR<ExerciseLogRelationFilter, ExerciseLogWhereInput> | null
  }

  export type ExerciseTimeOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    weight?: SortOrder
    repeat?: SortOrder
    isCompleted?: SortOrder
    exerciseLogId?: SortOrder
    exerciseLog?: ExerciseLogOrderByWithRelationInput
  }

  export type ExerciseTimeWhereUniqueInput = {
    id?: number
  }

  export type ExerciseTimeOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    weight?: SortOrder
    repeat?: SortOrder
    isCompleted?: SortOrder
    exerciseLogId?: SortOrder
    _count?: ExerciseTimeCountOrderByAggregateInput
    _avg?: ExerciseTimeAvgOrderByAggregateInput
    _max?: ExerciseTimeMaxOrderByAggregateInput
    _min?: ExerciseTimeMinOrderByAggregateInput
    _sum?: ExerciseTimeSumOrderByAggregateInput
  }

  export type ExerciseTimeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ExerciseTimeScalarWhereWithAggregatesInput>
    OR?: Enumerable<ExerciseTimeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ExerciseTimeScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    weight?: IntWithAggregatesFilter | number
    repeat?: IntWithAggregatesFilter | number
    isCompleted?: BoolWithAggregatesFilter | boolean
    exerciseLogId?: IntNullableWithAggregatesFilter | number | null
  }

  export type WorkoutLogWhereInput = {
    AND?: Enumerable<WorkoutLogWhereInput>
    OR?: Enumerable<WorkoutLogWhereInput>
    NOT?: Enumerable<WorkoutLogWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isCompleted?: BoolFilter | boolean
    userId?: IntNullableFilter | number | null
    workoutId?: IntNullableFilter | number | null
    exerciseLogs?: ExerciseLogListRelationFilter
    user?: XOR<UserRelationFilter, UserWhereInput> | null
    workout?: XOR<WorkoutRelationFilter, WorkoutWhereInput> | null
  }

  export type WorkoutLogOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCompleted?: SortOrder
    userId?: SortOrder
    workoutId?: SortOrder
    exerciseLogs?: ExerciseLogOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    workout?: WorkoutOrderByWithRelationInput
  }

  export type WorkoutLogWhereUniqueInput = {
    id?: number
  }

  export type WorkoutLogOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCompleted?: SortOrder
    userId?: SortOrder
    workoutId?: SortOrder
    _count?: WorkoutLogCountOrderByAggregateInput
    _avg?: WorkoutLogAvgOrderByAggregateInput
    _max?: WorkoutLogMaxOrderByAggregateInput
    _min?: WorkoutLogMinOrderByAggregateInput
    _sum?: WorkoutLogSumOrderByAggregateInput
  }

  export type WorkoutLogScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WorkoutLogScalarWhereWithAggregatesInput>
    OR?: Enumerable<WorkoutLogScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WorkoutLogScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    createdAt?: DateTimeWithAggregatesFilter | Date | string
    updatedAt?: DateTimeWithAggregatesFilter | Date | string
    isCompleted?: BoolWithAggregatesFilter | boolean
    userId?: IntNullableWithAggregatesFilter | number | null
    workoutId?: IntNullableWithAggregatesFilter | number | null
  }

  export type UserCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
    password: string
    images?: UserCreateimagesInput | Enumerable<string>
    exerciseLogs?: ExerciseLogCreateNestedManyWithoutUserInput
    workoutLogs?: WorkoutLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
    password: string
    images?: UserCreateimagesInput | Enumerable<string>
    exerciseLogs?: ExerciseLogUncheckedCreateNestedManyWithoutUserInput
    workoutLogs?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    images?: UserUpdateimagesInput | Enumerable<string>
    exerciseLogs?: ExerciseLogUpdateManyWithoutUserNestedInput
    workoutLogs?: WorkoutLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    images?: UserUpdateimagesInput | Enumerable<string>
    exerciseLogs?: ExerciseLogUncheckedUpdateManyWithoutUserNestedInput
    workoutLogs?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
    password: string
    images?: UserCreateimagesInput | Enumerable<string>
  }

  export type UserUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    images?: UserUpdateimagesInput | Enumerable<string>
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    images?: UserUpdateimagesInput | Enumerable<string>
  }

  export type WorkoutCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    exercises?: ExerciseCreateNestedManyWithoutWorkoutsInput
    workoutLogs?: WorkoutLogCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    exercises?: ExerciseUncheckedCreateNestedManyWithoutWorkoutsInput
    workoutLogs?: WorkoutLogUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    exercises?: ExerciseUpdateManyWithoutWorkoutsNestedInput
    workoutLogs?: WorkoutLogUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    exercises?: ExerciseUncheckedUpdateManyWithoutWorkoutsNestedInput
    workoutLogs?: WorkoutLogUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
  }

  export type WorkoutUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type WorkoutUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    times: number
    iconPath: string
    workouts?: WorkoutCreateNestedManyWithoutExercisesInput
    exerciseLog?: ExerciseLogCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    times: number
    iconPath: string
    workouts?: WorkoutUncheckedCreateNestedManyWithoutExercisesInput
    exerciseLog?: ExerciseLogUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    times?: IntFieldUpdateOperationsInput | number
    iconPath?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUpdateManyWithoutExercisesNestedInput
    exerciseLog?: ExerciseLogUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    times?: IntFieldUpdateOperationsInput | number
    iconPath?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUncheckedUpdateManyWithoutExercisesNestedInput
    exerciseLog?: ExerciseLogUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    times: number
    iconPath: string
  }

  export type ExerciseUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    times?: IntFieldUpdateOperationsInput | number
    iconPath?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    times?: IntFieldUpdateOperationsInput | number
    iconPath?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseLogCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    times?: ExerciseTimeCreateNestedManyWithoutExerciseLogInput
    user?: UserCreateNestedOneWithoutExerciseLogsInput
    workoutLog?: WorkoutLogCreateNestedOneWithoutExerciseLogsInput
    exercise?: ExerciseCreateNestedOneWithoutExerciseLogInput
  }

  export type ExerciseLogUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
    workoutLogId?: number | null
    exerciseId?: number | null
    times?: ExerciseTimeUncheckedCreateNestedManyWithoutExerciseLogInput
  }

  export type ExerciseLogUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    times?: ExerciseTimeUpdateManyWithoutExerciseLogNestedInput
    user?: UserUpdateOneWithoutExerciseLogsNestedInput
    workoutLog?: WorkoutLogUpdateOneWithoutExerciseLogsNestedInput
    exercise?: ExerciseUpdateOneWithoutExerciseLogNestedInput
  }

  export type ExerciseLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutLogId?: NullableIntFieldUpdateOperationsInput | number | null
    exerciseId?: NullableIntFieldUpdateOperationsInput | number | null
    times?: ExerciseTimeUncheckedUpdateManyWithoutExerciseLogNestedInput
  }

  export type ExerciseLogCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
    workoutLogId?: number | null
    exerciseId?: number | null
  }

  export type ExerciseLogUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExerciseLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutLogId?: NullableIntFieldUpdateOperationsInput | number | null
    exerciseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseTimeCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    weight?: number
    repeat?: number
    isCompleted?: boolean
    exerciseLog?: ExerciseLogCreateNestedOneWithoutTimesInput
  }

  export type ExerciseTimeUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    weight?: number
    repeat?: number
    isCompleted?: boolean
    exerciseLogId?: number | null
  }

  export type ExerciseTimeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: IntFieldUpdateOperationsInput | number
    repeat?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    exerciseLog?: ExerciseLogUpdateOneWithoutTimesNestedInput
  }

  export type ExerciseTimeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: IntFieldUpdateOperationsInput | number
    repeat?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    exerciseLogId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseTimeCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    weight?: number
    repeat?: number
    isCompleted?: boolean
    exerciseLogId?: number | null
  }

  export type ExerciseTimeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: IntFieldUpdateOperationsInput | number
    repeat?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExerciseTimeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: IntFieldUpdateOperationsInput | number
    repeat?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    exerciseLogId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkoutLogCreateInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    exerciseLogs?: ExerciseLogCreateNestedManyWithoutWorkoutLogInput
    user?: UserCreateNestedOneWithoutWorkoutLogsInput
    workout?: WorkoutCreateNestedOneWithoutWorkoutLogsInput
  }

  export type WorkoutLogUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
    workoutId?: number | null
    exerciseLogs?: ExerciseLogUncheckedCreateNestedManyWithoutWorkoutLogInput
  }

  export type WorkoutLogUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    exerciseLogs?: ExerciseLogUpdateManyWithoutWorkoutLogNestedInput
    user?: UserUpdateOneWithoutWorkoutLogsNestedInput
    workout?: WorkoutUpdateOneWithoutWorkoutLogsNestedInput
  }

  export type WorkoutLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
    exerciseLogs?: ExerciseLogUncheckedUpdateManyWithoutWorkoutLogNestedInput
  }

  export type WorkoutLogCreateManyInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
    workoutId?: number | null
  }

  export type WorkoutLogUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type WorkoutLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type StringNullableListFilter = {
    equals?: Enumerable<string> | null
    has?: string | null
    hasEvery?: Enumerable<string>
    hasSome?: Enumerable<string>
    isEmpty?: boolean
  }

  export type ExerciseLogListRelationFilter = {
    every?: ExerciseLogWhereInput
    some?: ExerciseLogWhereInput
    none?: ExerciseLogWhereInput
  }

  export type WorkoutLogListRelationFilter = {
    every?: WorkoutLogWhereInput
    some?: WorkoutLogWhereInput
    none?: WorkoutLogWhereInput
  }

  export type ExerciseLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
    images?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    email?: SortOrder
    name?: SortOrder
    password?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type ExerciseListRelationFilter = {
    every?: ExerciseWhereInput
    some?: ExerciseWhereInput
    none?: ExerciseWhereInput
  }

  export type ExerciseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkoutCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type WorkoutAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WorkoutMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type WorkoutMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
  }

  export type WorkoutSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WorkoutListRelationFilter = {
    every?: WorkoutWhereInput
    some?: WorkoutWhereInput
    none?: WorkoutWhereInput
  }

  export type WorkoutOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    times?: SortOrder
    iconPath?: SortOrder
  }

  export type ExerciseAvgOrderByAggregateInput = {
    id?: SortOrder
    times?: SortOrder
  }

  export type ExerciseMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    times?: SortOrder
    iconPath?: SortOrder
  }

  export type ExerciseMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    name?: SortOrder
    times?: SortOrder
    iconPath?: SortOrder
  }

  export type ExerciseSumOrderByAggregateInput = {
    id?: SortOrder
    times?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type ExerciseTimeListRelationFilter = {
    every?: ExerciseTimeWhereInput
    some?: ExerciseTimeWhereInput
    none?: ExerciseTimeWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type WorkoutLogRelationFilter = {
    is?: WorkoutLogWhereInput | null
    isNot?: WorkoutLogWhereInput | null
  }

  export type ExerciseRelationFilter = {
    is?: ExerciseWhereInput | null
    isNot?: ExerciseWhereInput | null
  }

  export type ExerciseTimeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExerciseLogCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCompleted?: SortOrder
    userId?: SortOrder
    workoutLogId?: SortOrder
    exerciseId?: SortOrder
  }

  export type ExerciseLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workoutLogId?: SortOrder
    exerciseId?: SortOrder
  }

  export type ExerciseLogMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCompleted?: SortOrder
    userId?: SortOrder
    workoutLogId?: SortOrder
    exerciseId?: SortOrder
  }

  export type ExerciseLogMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCompleted?: SortOrder
    userId?: SortOrder
    workoutLogId?: SortOrder
    exerciseId?: SortOrder
  }

  export type ExerciseLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workoutLogId?: SortOrder
    exerciseId?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type ExerciseLogRelationFilter = {
    is?: ExerciseLogWhereInput | null
    isNot?: ExerciseLogWhereInput | null
  }

  export type ExerciseTimeCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    weight?: SortOrder
    repeat?: SortOrder
    isCompleted?: SortOrder
    exerciseLogId?: SortOrder
  }

  export type ExerciseTimeAvgOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    repeat?: SortOrder
    exerciseLogId?: SortOrder
  }

  export type ExerciseTimeMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    weight?: SortOrder
    repeat?: SortOrder
    isCompleted?: SortOrder
    exerciseLogId?: SortOrder
  }

  export type ExerciseTimeMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    weight?: SortOrder
    repeat?: SortOrder
    isCompleted?: SortOrder
    exerciseLogId?: SortOrder
  }

  export type ExerciseTimeSumOrderByAggregateInput = {
    id?: SortOrder
    weight?: SortOrder
    repeat?: SortOrder
    exerciseLogId?: SortOrder
  }

  export type WorkoutRelationFilter = {
    is?: WorkoutWhereInput | null
    isNot?: WorkoutWhereInput | null
  }

  export type WorkoutLogCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCompleted?: SortOrder
    userId?: SortOrder
    workoutId?: SortOrder
  }

  export type WorkoutLogAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workoutId?: SortOrder
  }

  export type WorkoutLogMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCompleted?: SortOrder
    userId?: SortOrder
    workoutId?: SortOrder
  }

  export type WorkoutLogMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isCompleted?: SortOrder
    userId?: SortOrder
    workoutId?: SortOrder
  }

  export type WorkoutLogSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workoutId?: SortOrder
  }

  export type UserCreateimagesInput = {
    set: Enumerable<string>
  }

  export type ExerciseLogCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutUserInput>, Enumerable<ExerciseLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutUserInput>
    createMany?: ExerciseLogCreateManyUserInputEnvelope
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
  }

  export type WorkoutLogCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WorkoutLogCreateWithoutUserInput>, Enumerable<WorkoutLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkoutLogCreateOrConnectWithoutUserInput>
    createMany?: WorkoutLogCreateManyUserInputEnvelope
    connect?: Enumerable<WorkoutLogWhereUniqueInput>
  }

  export type ExerciseLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutUserInput>, Enumerable<ExerciseLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutUserInput>
    createMany?: ExerciseLogCreateManyUserInputEnvelope
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
  }

  export type WorkoutLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<WorkoutLogCreateWithoutUserInput>, Enumerable<WorkoutLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkoutLogCreateOrConnectWithoutUserInput>
    createMany?: WorkoutLogCreateManyUserInputEnvelope
    connect?: Enumerable<WorkoutLogWhereUniqueInput>
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserUpdateimagesInput = {
    set?: Enumerable<string>
    push?: string | Enumerable<string>
  }

  export type ExerciseLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutUserInput>, Enumerable<ExerciseLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ExerciseLogUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ExerciseLogCreateManyUserInputEnvelope
    set?: Enumerable<ExerciseLogWhereUniqueInput>
    disconnect?: Enumerable<ExerciseLogWhereUniqueInput>
    delete?: Enumerable<ExerciseLogWhereUniqueInput>
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
    update?: Enumerable<ExerciseLogUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ExerciseLogUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ExerciseLogScalarWhereInput>
  }

  export type WorkoutLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WorkoutLogCreateWithoutUserInput>, Enumerable<WorkoutLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkoutLogCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WorkoutLogUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WorkoutLogCreateManyUserInputEnvelope
    set?: Enumerable<WorkoutLogWhereUniqueInput>
    disconnect?: Enumerable<WorkoutLogWhereUniqueInput>
    delete?: Enumerable<WorkoutLogWhereUniqueInput>
    connect?: Enumerable<WorkoutLogWhereUniqueInput>
    update?: Enumerable<WorkoutLogUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WorkoutLogUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WorkoutLogScalarWhereInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExerciseLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutUserInput>, Enumerable<ExerciseLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<ExerciseLogUpsertWithWhereUniqueWithoutUserInput>
    createMany?: ExerciseLogCreateManyUserInputEnvelope
    set?: Enumerable<ExerciseLogWhereUniqueInput>
    disconnect?: Enumerable<ExerciseLogWhereUniqueInput>
    delete?: Enumerable<ExerciseLogWhereUniqueInput>
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
    update?: Enumerable<ExerciseLogUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<ExerciseLogUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<ExerciseLogScalarWhereInput>
  }

  export type WorkoutLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<WorkoutLogCreateWithoutUserInput>, Enumerable<WorkoutLogUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<WorkoutLogCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<WorkoutLogUpsertWithWhereUniqueWithoutUserInput>
    createMany?: WorkoutLogCreateManyUserInputEnvelope
    set?: Enumerable<WorkoutLogWhereUniqueInput>
    disconnect?: Enumerable<WorkoutLogWhereUniqueInput>
    delete?: Enumerable<WorkoutLogWhereUniqueInput>
    connect?: Enumerable<WorkoutLogWhereUniqueInput>
    update?: Enumerable<WorkoutLogUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<WorkoutLogUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<WorkoutLogScalarWhereInput>
  }

  export type ExerciseCreateNestedManyWithoutWorkoutsInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutWorkoutsInput>, Enumerable<ExerciseUncheckedCreateWithoutWorkoutsInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutWorkoutsInput>
    connect?: Enumerable<ExerciseWhereUniqueInput>
  }

  export type WorkoutLogCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<Enumerable<WorkoutLogCreateWithoutWorkoutInput>, Enumerable<WorkoutLogUncheckedCreateWithoutWorkoutInput>>
    connectOrCreate?: Enumerable<WorkoutLogCreateOrConnectWithoutWorkoutInput>
    createMany?: WorkoutLogCreateManyWorkoutInputEnvelope
    connect?: Enumerable<WorkoutLogWhereUniqueInput>
  }

  export type ExerciseUncheckedCreateNestedManyWithoutWorkoutsInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutWorkoutsInput>, Enumerable<ExerciseUncheckedCreateWithoutWorkoutsInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutWorkoutsInput>
    connect?: Enumerable<ExerciseWhereUniqueInput>
  }

  export type WorkoutLogUncheckedCreateNestedManyWithoutWorkoutInput = {
    create?: XOR<Enumerable<WorkoutLogCreateWithoutWorkoutInput>, Enumerable<WorkoutLogUncheckedCreateWithoutWorkoutInput>>
    connectOrCreate?: Enumerable<WorkoutLogCreateOrConnectWithoutWorkoutInput>
    createMany?: WorkoutLogCreateManyWorkoutInputEnvelope
    connect?: Enumerable<WorkoutLogWhereUniqueInput>
  }

  export type ExerciseUpdateManyWithoutWorkoutsNestedInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutWorkoutsInput>, Enumerable<ExerciseUncheckedCreateWithoutWorkoutsInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutWorkoutsInput>
    upsert?: Enumerable<ExerciseUpsertWithWhereUniqueWithoutWorkoutsInput>
    set?: Enumerable<ExerciseWhereUniqueInput>
    disconnect?: Enumerable<ExerciseWhereUniqueInput>
    delete?: Enumerable<ExerciseWhereUniqueInput>
    connect?: Enumerable<ExerciseWhereUniqueInput>
    update?: Enumerable<ExerciseUpdateWithWhereUniqueWithoutWorkoutsInput>
    updateMany?: Enumerable<ExerciseUpdateManyWithWhereWithoutWorkoutsInput>
    deleteMany?: Enumerable<ExerciseScalarWhereInput>
  }

  export type WorkoutLogUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<Enumerable<WorkoutLogCreateWithoutWorkoutInput>, Enumerable<WorkoutLogUncheckedCreateWithoutWorkoutInput>>
    connectOrCreate?: Enumerable<WorkoutLogCreateOrConnectWithoutWorkoutInput>
    upsert?: Enumerable<WorkoutLogUpsertWithWhereUniqueWithoutWorkoutInput>
    createMany?: WorkoutLogCreateManyWorkoutInputEnvelope
    set?: Enumerable<WorkoutLogWhereUniqueInput>
    disconnect?: Enumerable<WorkoutLogWhereUniqueInput>
    delete?: Enumerable<WorkoutLogWhereUniqueInput>
    connect?: Enumerable<WorkoutLogWhereUniqueInput>
    update?: Enumerable<WorkoutLogUpdateWithWhereUniqueWithoutWorkoutInput>
    updateMany?: Enumerable<WorkoutLogUpdateManyWithWhereWithoutWorkoutInput>
    deleteMany?: Enumerable<WorkoutLogScalarWhereInput>
  }

  export type ExerciseUncheckedUpdateManyWithoutWorkoutsNestedInput = {
    create?: XOR<Enumerable<ExerciseCreateWithoutWorkoutsInput>, Enumerable<ExerciseUncheckedCreateWithoutWorkoutsInput>>
    connectOrCreate?: Enumerable<ExerciseCreateOrConnectWithoutWorkoutsInput>
    upsert?: Enumerable<ExerciseUpsertWithWhereUniqueWithoutWorkoutsInput>
    set?: Enumerable<ExerciseWhereUniqueInput>
    disconnect?: Enumerable<ExerciseWhereUniqueInput>
    delete?: Enumerable<ExerciseWhereUniqueInput>
    connect?: Enumerable<ExerciseWhereUniqueInput>
    update?: Enumerable<ExerciseUpdateWithWhereUniqueWithoutWorkoutsInput>
    updateMany?: Enumerable<ExerciseUpdateManyWithWhereWithoutWorkoutsInput>
    deleteMany?: Enumerable<ExerciseScalarWhereInput>
  }

  export type WorkoutLogUncheckedUpdateManyWithoutWorkoutNestedInput = {
    create?: XOR<Enumerable<WorkoutLogCreateWithoutWorkoutInput>, Enumerable<WorkoutLogUncheckedCreateWithoutWorkoutInput>>
    connectOrCreate?: Enumerable<WorkoutLogCreateOrConnectWithoutWorkoutInput>
    upsert?: Enumerable<WorkoutLogUpsertWithWhereUniqueWithoutWorkoutInput>
    createMany?: WorkoutLogCreateManyWorkoutInputEnvelope
    set?: Enumerable<WorkoutLogWhereUniqueInput>
    disconnect?: Enumerable<WorkoutLogWhereUniqueInput>
    delete?: Enumerable<WorkoutLogWhereUniqueInput>
    connect?: Enumerable<WorkoutLogWhereUniqueInput>
    update?: Enumerable<WorkoutLogUpdateWithWhereUniqueWithoutWorkoutInput>
    updateMany?: Enumerable<WorkoutLogUpdateManyWithWhereWithoutWorkoutInput>
    deleteMany?: Enumerable<WorkoutLogScalarWhereInput>
  }

  export type WorkoutCreateNestedManyWithoutExercisesInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutExercisesInput>, Enumerable<WorkoutUncheckedCreateWithoutExercisesInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutExercisesInput>
    connect?: Enumerable<WorkoutWhereUniqueInput>
  }

  export type ExerciseLogCreateNestedManyWithoutExerciseInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutExerciseInput>, Enumerable<ExerciseLogUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutExerciseInput>
    createMany?: ExerciseLogCreateManyExerciseInputEnvelope
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
  }

  export type WorkoutUncheckedCreateNestedManyWithoutExercisesInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutExercisesInput>, Enumerable<WorkoutUncheckedCreateWithoutExercisesInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutExercisesInput>
    connect?: Enumerable<WorkoutWhereUniqueInput>
  }

  export type ExerciseLogUncheckedCreateNestedManyWithoutExerciseInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutExerciseInput>, Enumerable<ExerciseLogUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutExerciseInput>
    createMany?: ExerciseLogCreateManyExerciseInputEnvelope
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
  }

  export type WorkoutUpdateManyWithoutExercisesNestedInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutExercisesInput>, Enumerable<WorkoutUncheckedCreateWithoutExercisesInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutExercisesInput>
    upsert?: Enumerable<WorkoutUpsertWithWhereUniqueWithoutExercisesInput>
    set?: Enumerable<WorkoutWhereUniqueInput>
    disconnect?: Enumerable<WorkoutWhereUniqueInput>
    delete?: Enumerable<WorkoutWhereUniqueInput>
    connect?: Enumerable<WorkoutWhereUniqueInput>
    update?: Enumerable<WorkoutUpdateWithWhereUniqueWithoutExercisesInput>
    updateMany?: Enumerable<WorkoutUpdateManyWithWhereWithoutExercisesInput>
    deleteMany?: Enumerable<WorkoutScalarWhereInput>
  }

  export type ExerciseLogUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutExerciseInput>, Enumerable<ExerciseLogUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutExerciseInput>
    upsert?: Enumerable<ExerciseLogUpsertWithWhereUniqueWithoutExerciseInput>
    createMany?: ExerciseLogCreateManyExerciseInputEnvelope
    set?: Enumerable<ExerciseLogWhereUniqueInput>
    disconnect?: Enumerable<ExerciseLogWhereUniqueInput>
    delete?: Enumerable<ExerciseLogWhereUniqueInput>
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
    update?: Enumerable<ExerciseLogUpdateWithWhereUniqueWithoutExerciseInput>
    updateMany?: Enumerable<ExerciseLogUpdateManyWithWhereWithoutExerciseInput>
    deleteMany?: Enumerable<ExerciseLogScalarWhereInput>
  }

  export type WorkoutUncheckedUpdateManyWithoutExercisesNestedInput = {
    create?: XOR<Enumerable<WorkoutCreateWithoutExercisesInput>, Enumerable<WorkoutUncheckedCreateWithoutExercisesInput>>
    connectOrCreate?: Enumerable<WorkoutCreateOrConnectWithoutExercisesInput>
    upsert?: Enumerable<WorkoutUpsertWithWhereUniqueWithoutExercisesInput>
    set?: Enumerable<WorkoutWhereUniqueInput>
    disconnect?: Enumerable<WorkoutWhereUniqueInput>
    delete?: Enumerable<WorkoutWhereUniqueInput>
    connect?: Enumerable<WorkoutWhereUniqueInput>
    update?: Enumerable<WorkoutUpdateWithWhereUniqueWithoutExercisesInput>
    updateMany?: Enumerable<WorkoutUpdateManyWithWhereWithoutExercisesInput>
    deleteMany?: Enumerable<WorkoutScalarWhereInput>
  }

  export type ExerciseLogUncheckedUpdateManyWithoutExerciseNestedInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutExerciseInput>, Enumerable<ExerciseLogUncheckedCreateWithoutExerciseInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutExerciseInput>
    upsert?: Enumerable<ExerciseLogUpsertWithWhereUniqueWithoutExerciseInput>
    createMany?: ExerciseLogCreateManyExerciseInputEnvelope
    set?: Enumerable<ExerciseLogWhereUniqueInput>
    disconnect?: Enumerable<ExerciseLogWhereUniqueInput>
    delete?: Enumerable<ExerciseLogWhereUniqueInput>
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
    update?: Enumerable<ExerciseLogUpdateWithWhereUniqueWithoutExerciseInput>
    updateMany?: Enumerable<ExerciseLogUpdateManyWithWhereWithoutExerciseInput>
    deleteMany?: Enumerable<ExerciseLogScalarWhereInput>
  }

  export type ExerciseTimeCreateNestedManyWithoutExerciseLogInput = {
    create?: XOR<Enumerable<ExerciseTimeCreateWithoutExerciseLogInput>, Enumerable<ExerciseTimeUncheckedCreateWithoutExerciseLogInput>>
    connectOrCreate?: Enumerable<ExerciseTimeCreateOrConnectWithoutExerciseLogInput>
    createMany?: ExerciseTimeCreateManyExerciseLogInputEnvelope
    connect?: Enumerable<ExerciseTimeWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutExerciseLogsInput = {
    create?: XOR<UserCreateWithoutExerciseLogsInput, UserUncheckedCreateWithoutExerciseLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExerciseLogsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkoutLogCreateNestedOneWithoutExerciseLogsInput = {
    create?: XOR<WorkoutLogCreateWithoutExerciseLogsInput, WorkoutLogUncheckedCreateWithoutExerciseLogsInput>
    connectOrCreate?: WorkoutLogCreateOrConnectWithoutExerciseLogsInput
    connect?: WorkoutLogWhereUniqueInput
  }

  export type ExerciseCreateNestedOneWithoutExerciseLogInput = {
    create?: XOR<ExerciseCreateWithoutExerciseLogInput, ExerciseUncheckedCreateWithoutExerciseLogInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutExerciseLogInput
    connect?: ExerciseWhereUniqueInput
  }

  export type ExerciseTimeUncheckedCreateNestedManyWithoutExerciseLogInput = {
    create?: XOR<Enumerable<ExerciseTimeCreateWithoutExerciseLogInput>, Enumerable<ExerciseTimeUncheckedCreateWithoutExerciseLogInput>>
    connectOrCreate?: Enumerable<ExerciseTimeCreateOrConnectWithoutExerciseLogInput>
    createMany?: ExerciseTimeCreateManyExerciseLogInputEnvelope
    connect?: Enumerable<ExerciseTimeWhereUniqueInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ExerciseTimeUpdateManyWithoutExerciseLogNestedInput = {
    create?: XOR<Enumerable<ExerciseTimeCreateWithoutExerciseLogInput>, Enumerable<ExerciseTimeUncheckedCreateWithoutExerciseLogInput>>
    connectOrCreate?: Enumerable<ExerciseTimeCreateOrConnectWithoutExerciseLogInput>
    upsert?: Enumerable<ExerciseTimeUpsertWithWhereUniqueWithoutExerciseLogInput>
    createMany?: ExerciseTimeCreateManyExerciseLogInputEnvelope
    set?: Enumerable<ExerciseTimeWhereUniqueInput>
    disconnect?: Enumerable<ExerciseTimeWhereUniqueInput>
    delete?: Enumerable<ExerciseTimeWhereUniqueInput>
    connect?: Enumerable<ExerciseTimeWhereUniqueInput>
    update?: Enumerable<ExerciseTimeUpdateWithWhereUniqueWithoutExerciseLogInput>
    updateMany?: Enumerable<ExerciseTimeUpdateManyWithWhereWithoutExerciseLogInput>
    deleteMany?: Enumerable<ExerciseTimeScalarWhereInput>
  }

  export type UserUpdateOneWithoutExerciseLogsNestedInput = {
    create?: XOR<UserCreateWithoutExerciseLogsInput, UserUncheckedCreateWithoutExerciseLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExerciseLogsInput
    upsert?: UserUpsertWithoutExerciseLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutExerciseLogsInput, UserUncheckedUpdateWithoutExerciseLogsInput>
  }

  export type WorkoutLogUpdateOneWithoutExerciseLogsNestedInput = {
    create?: XOR<WorkoutLogCreateWithoutExerciseLogsInput, WorkoutLogUncheckedCreateWithoutExerciseLogsInput>
    connectOrCreate?: WorkoutLogCreateOrConnectWithoutExerciseLogsInput
    upsert?: WorkoutLogUpsertWithoutExerciseLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: WorkoutLogWhereUniqueInput
    update?: XOR<WorkoutLogUpdateWithoutExerciseLogsInput, WorkoutLogUncheckedUpdateWithoutExerciseLogsInput>
  }

  export type ExerciseUpdateOneWithoutExerciseLogNestedInput = {
    create?: XOR<ExerciseCreateWithoutExerciseLogInput, ExerciseUncheckedCreateWithoutExerciseLogInput>
    connectOrCreate?: ExerciseCreateOrConnectWithoutExerciseLogInput
    upsert?: ExerciseUpsertWithoutExerciseLogInput
    disconnect?: boolean
    delete?: boolean
    connect?: ExerciseWhereUniqueInput
    update?: XOR<ExerciseUpdateWithoutExerciseLogInput, ExerciseUncheckedUpdateWithoutExerciseLogInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExerciseTimeUncheckedUpdateManyWithoutExerciseLogNestedInput = {
    create?: XOR<Enumerable<ExerciseTimeCreateWithoutExerciseLogInput>, Enumerable<ExerciseTimeUncheckedCreateWithoutExerciseLogInput>>
    connectOrCreate?: Enumerable<ExerciseTimeCreateOrConnectWithoutExerciseLogInput>
    upsert?: Enumerable<ExerciseTimeUpsertWithWhereUniqueWithoutExerciseLogInput>
    createMany?: ExerciseTimeCreateManyExerciseLogInputEnvelope
    set?: Enumerable<ExerciseTimeWhereUniqueInput>
    disconnect?: Enumerable<ExerciseTimeWhereUniqueInput>
    delete?: Enumerable<ExerciseTimeWhereUniqueInput>
    connect?: Enumerable<ExerciseTimeWhereUniqueInput>
    update?: Enumerable<ExerciseTimeUpdateWithWhereUniqueWithoutExerciseLogInput>
    updateMany?: Enumerable<ExerciseTimeUpdateManyWithWhereWithoutExerciseLogInput>
    deleteMany?: Enumerable<ExerciseTimeScalarWhereInput>
  }

  export type ExerciseLogCreateNestedOneWithoutTimesInput = {
    create?: XOR<ExerciseLogCreateWithoutTimesInput, ExerciseLogUncheckedCreateWithoutTimesInput>
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutTimesInput
    connect?: ExerciseLogWhereUniqueInput
  }

  export type ExerciseLogUpdateOneWithoutTimesNestedInput = {
    create?: XOR<ExerciseLogCreateWithoutTimesInput, ExerciseLogUncheckedCreateWithoutTimesInput>
    connectOrCreate?: ExerciseLogCreateOrConnectWithoutTimesInput
    upsert?: ExerciseLogUpsertWithoutTimesInput
    disconnect?: boolean
    delete?: boolean
    connect?: ExerciseLogWhereUniqueInput
    update?: XOR<ExerciseLogUpdateWithoutTimesInput, ExerciseLogUncheckedUpdateWithoutTimesInput>
  }

  export type ExerciseLogCreateNestedManyWithoutWorkoutLogInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutWorkoutLogInput>, Enumerable<ExerciseLogUncheckedCreateWithoutWorkoutLogInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutWorkoutLogInput>
    createMany?: ExerciseLogCreateManyWorkoutLogInputEnvelope
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
  }

  export type UserCreateNestedOneWithoutWorkoutLogsInput = {
    create?: XOR<UserCreateWithoutWorkoutLogsInput, UserUncheckedCreateWithoutWorkoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutLogsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkoutCreateNestedOneWithoutWorkoutLogsInput = {
    create?: XOR<WorkoutCreateWithoutWorkoutLogsInput, WorkoutUncheckedCreateWithoutWorkoutLogsInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutWorkoutLogsInput
    connect?: WorkoutWhereUniqueInput
  }

  export type ExerciseLogUncheckedCreateNestedManyWithoutWorkoutLogInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutWorkoutLogInput>, Enumerable<ExerciseLogUncheckedCreateWithoutWorkoutLogInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutWorkoutLogInput>
    createMany?: ExerciseLogCreateManyWorkoutLogInputEnvelope
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
  }

  export type ExerciseLogUpdateManyWithoutWorkoutLogNestedInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutWorkoutLogInput>, Enumerable<ExerciseLogUncheckedCreateWithoutWorkoutLogInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutWorkoutLogInput>
    upsert?: Enumerable<ExerciseLogUpsertWithWhereUniqueWithoutWorkoutLogInput>
    createMany?: ExerciseLogCreateManyWorkoutLogInputEnvelope
    set?: Enumerable<ExerciseLogWhereUniqueInput>
    disconnect?: Enumerable<ExerciseLogWhereUniqueInput>
    delete?: Enumerable<ExerciseLogWhereUniqueInput>
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
    update?: Enumerable<ExerciseLogUpdateWithWhereUniqueWithoutWorkoutLogInput>
    updateMany?: Enumerable<ExerciseLogUpdateManyWithWhereWithoutWorkoutLogInput>
    deleteMany?: Enumerable<ExerciseLogScalarWhereInput>
  }

  export type UserUpdateOneWithoutWorkoutLogsNestedInput = {
    create?: XOR<UserCreateWithoutWorkoutLogsInput, UserUncheckedCreateWithoutWorkoutLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkoutLogsInput
    upsert?: UserUpsertWithoutWorkoutLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: UserWhereUniqueInput
    update?: XOR<UserUpdateWithoutWorkoutLogsInput, UserUncheckedUpdateWithoutWorkoutLogsInput>
  }

  export type WorkoutUpdateOneWithoutWorkoutLogsNestedInput = {
    create?: XOR<WorkoutCreateWithoutWorkoutLogsInput, WorkoutUncheckedCreateWithoutWorkoutLogsInput>
    connectOrCreate?: WorkoutCreateOrConnectWithoutWorkoutLogsInput
    upsert?: WorkoutUpsertWithoutWorkoutLogsInput
    disconnect?: boolean
    delete?: boolean
    connect?: WorkoutWhereUniqueInput
    update?: XOR<WorkoutUpdateWithoutWorkoutLogsInput, WorkoutUncheckedUpdateWithoutWorkoutLogsInput>
  }

  export type ExerciseLogUncheckedUpdateManyWithoutWorkoutLogNestedInput = {
    create?: XOR<Enumerable<ExerciseLogCreateWithoutWorkoutLogInput>, Enumerable<ExerciseLogUncheckedCreateWithoutWorkoutLogInput>>
    connectOrCreate?: Enumerable<ExerciseLogCreateOrConnectWithoutWorkoutLogInput>
    upsert?: Enumerable<ExerciseLogUpsertWithWhereUniqueWithoutWorkoutLogInput>
    createMany?: ExerciseLogCreateManyWorkoutLogInputEnvelope
    set?: Enumerable<ExerciseLogWhereUniqueInput>
    disconnect?: Enumerable<ExerciseLogWhereUniqueInput>
    delete?: Enumerable<ExerciseLogWhereUniqueInput>
    connect?: Enumerable<ExerciseLogWhereUniqueInput>
    update?: Enumerable<ExerciseLogUpdateWithWhereUniqueWithoutWorkoutLogInput>
    updateMany?: Enumerable<ExerciseLogUpdateManyWithWhereWithoutWorkoutLogInput>
    deleteMany?: Enumerable<ExerciseLogScalarWhereInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type ExerciseLogCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    times?: ExerciseTimeCreateNestedManyWithoutExerciseLogInput
    workoutLog?: WorkoutLogCreateNestedOneWithoutExerciseLogsInput
    exercise?: ExerciseCreateNestedOneWithoutExerciseLogInput
  }

  export type ExerciseLogUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    workoutLogId?: number | null
    exerciseId?: number | null
    times?: ExerciseTimeUncheckedCreateNestedManyWithoutExerciseLogInput
  }

  export type ExerciseLogCreateOrConnectWithoutUserInput = {
    where: ExerciseLogWhereUniqueInput
    create: XOR<ExerciseLogCreateWithoutUserInput, ExerciseLogUncheckedCreateWithoutUserInput>
  }

  export type ExerciseLogCreateManyUserInputEnvelope = {
    data: Enumerable<ExerciseLogCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type WorkoutLogCreateWithoutUserInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    exerciseLogs?: ExerciseLogCreateNestedManyWithoutWorkoutLogInput
    workout?: WorkoutCreateNestedOneWithoutWorkoutLogsInput
  }

  export type WorkoutLogUncheckedCreateWithoutUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    workoutId?: number | null
    exerciseLogs?: ExerciseLogUncheckedCreateNestedManyWithoutWorkoutLogInput
  }

  export type WorkoutLogCreateOrConnectWithoutUserInput = {
    where: WorkoutLogWhereUniqueInput
    create: XOR<WorkoutLogCreateWithoutUserInput, WorkoutLogUncheckedCreateWithoutUserInput>
  }

  export type WorkoutLogCreateManyUserInputEnvelope = {
    data: Enumerable<WorkoutLogCreateManyUserInput>
    skipDuplicates?: boolean
  }

  export type ExerciseLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ExerciseLogWhereUniqueInput
    update: XOR<ExerciseLogUpdateWithoutUserInput, ExerciseLogUncheckedUpdateWithoutUserInput>
    create: XOR<ExerciseLogCreateWithoutUserInput, ExerciseLogUncheckedCreateWithoutUserInput>
  }

  export type ExerciseLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ExerciseLogWhereUniqueInput
    data: XOR<ExerciseLogUpdateWithoutUserInput, ExerciseLogUncheckedUpdateWithoutUserInput>
  }

  export type ExerciseLogUpdateManyWithWhereWithoutUserInput = {
    where: ExerciseLogScalarWhereInput
    data: XOR<ExerciseLogUpdateManyMutationInput, ExerciseLogUncheckedUpdateManyWithoutExerciseLogsInput>
  }

  export type ExerciseLogScalarWhereInput = {
    AND?: Enumerable<ExerciseLogScalarWhereInput>
    OR?: Enumerable<ExerciseLogScalarWhereInput>
    NOT?: Enumerable<ExerciseLogScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isCompleted?: BoolFilter | boolean
    userId?: IntNullableFilter | number | null
    workoutLogId?: IntNullableFilter | number | null
    exerciseId?: IntNullableFilter | number | null
  }

  export type WorkoutLogUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkoutLogWhereUniqueInput
    update: XOR<WorkoutLogUpdateWithoutUserInput, WorkoutLogUncheckedUpdateWithoutUserInput>
    create: XOR<WorkoutLogCreateWithoutUserInput, WorkoutLogUncheckedCreateWithoutUserInput>
  }

  export type WorkoutLogUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkoutLogWhereUniqueInput
    data: XOR<WorkoutLogUpdateWithoutUserInput, WorkoutLogUncheckedUpdateWithoutUserInput>
  }

  export type WorkoutLogUpdateManyWithWhereWithoutUserInput = {
    where: WorkoutLogScalarWhereInput
    data: XOR<WorkoutLogUpdateManyMutationInput, WorkoutLogUncheckedUpdateManyWithoutWorkoutLogsInput>
  }

  export type WorkoutLogScalarWhereInput = {
    AND?: Enumerable<WorkoutLogScalarWhereInput>
    OR?: Enumerable<WorkoutLogScalarWhereInput>
    NOT?: Enumerable<WorkoutLogScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    isCompleted?: BoolFilter | boolean
    userId?: IntNullableFilter | number | null
    workoutId?: IntNullableFilter | number | null
  }

  export type ExerciseCreateWithoutWorkoutsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    times: number
    iconPath: string
    exerciseLog?: ExerciseLogCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseUncheckedCreateWithoutWorkoutsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    times: number
    iconPath: string
    exerciseLog?: ExerciseLogUncheckedCreateNestedManyWithoutExerciseInput
  }

  export type ExerciseCreateOrConnectWithoutWorkoutsInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutWorkoutsInput, ExerciseUncheckedCreateWithoutWorkoutsInput>
  }

  export type WorkoutLogCreateWithoutWorkoutInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    exerciseLogs?: ExerciseLogCreateNestedManyWithoutWorkoutLogInput
    user?: UserCreateNestedOneWithoutWorkoutLogsInput
  }

  export type WorkoutLogUncheckedCreateWithoutWorkoutInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
    exerciseLogs?: ExerciseLogUncheckedCreateNestedManyWithoutWorkoutLogInput
  }

  export type WorkoutLogCreateOrConnectWithoutWorkoutInput = {
    where: WorkoutLogWhereUniqueInput
    create: XOR<WorkoutLogCreateWithoutWorkoutInput, WorkoutLogUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutLogCreateManyWorkoutInputEnvelope = {
    data: Enumerable<WorkoutLogCreateManyWorkoutInput>
    skipDuplicates?: boolean
  }

  export type ExerciseUpsertWithWhereUniqueWithoutWorkoutsInput = {
    where: ExerciseWhereUniqueInput
    update: XOR<ExerciseUpdateWithoutWorkoutsInput, ExerciseUncheckedUpdateWithoutWorkoutsInput>
    create: XOR<ExerciseCreateWithoutWorkoutsInput, ExerciseUncheckedCreateWithoutWorkoutsInput>
  }

  export type ExerciseUpdateWithWhereUniqueWithoutWorkoutsInput = {
    where: ExerciseWhereUniqueInput
    data: XOR<ExerciseUpdateWithoutWorkoutsInput, ExerciseUncheckedUpdateWithoutWorkoutsInput>
  }

  export type ExerciseUpdateManyWithWhereWithoutWorkoutsInput = {
    where: ExerciseScalarWhereInput
    data: XOR<ExerciseUpdateManyMutationInput, ExerciseUncheckedUpdateManyWithoutExercisesInput>
  }

  export type ExerciseScalarWhereInput = {
    AND?: Enumerable<ExerciseScalarWhereInput>
    OR?: Enumerable<ExerciseScalarWhereInput>
    NOT?: Enumerable<ExerciseScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
    times?: IntFilter | number
    iconPath?: StringFilter | string
  }

  export type WorkoutLogUpsertWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutLogWhereUniqueInput
    update: XOR<WorkoutLogUpdateWithoutWorkoutInput, WorkoutLogUncheckedUpdateWithoutWorkoutInput>
    create: XOR<WorkoutLogCreateWithoutWorkoutInput, WorkoutLogUncheckedCreateWithoutWorkoutInput>
  }

  export type WorkoutLogUpdateWithWhereUniqueWithoutWorkoutInput = {
    where: WorkoutLogWhereUniqueInput
    data: XOR<WorkoutLogUpdateWithoutWorkoutInput, WorkoutLogUncheckedUpdateWithoutWorkoutInput>
  }

  export type WorkoutLogUpdateManyWithWhereWithoutWorkoutInput = {
    where: WorkoutLogScalarWhereInput
    data: XOR<WorkoutLogUpdateManyMutationInput, WorkoutLogUncheckedUpdateManyWithoutWorkoutLogsInput>
  }

  export type WorkoutCreateWithoutExercisesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    workoutLogs?: WorkoutLogCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutUncheckedCreateWithoutExercisesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    workoutLogs?: WorkoutLogUncheckedCreateNestedManyWithoutWorkoutInput
  }

  export type WorkoutCreateOrConnectWithoutExercisesInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutExercisesInput, WorkoutUncheckedCreateWithoutExercisesInput>
  }

  export type ExerciseLogCreateWithoutExerciseInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    times?: ExerciseTimeCreateNestedManyWithoutExerciseLogInput
    user?: UserCreateNestedOneWithoutExerciseLogsInput
    workoutLog?: WorkoutLogCreateNestedOneWithoutExerciseLogsInput
  }

  export type ExerciseLogUncheckedCreateWithoutExerciseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
    workoutLogId?: number | null
    times?: ExerciseTimeUncheckedCreateNestedManyWithoutExerciseLogInput
  }

  export type ExerciseLogCreateOrConnectWithoutExerciseInput = {
    where: ExerciseLogWhereUniqueInput
    create: XOR<ExerciseLogCreateWithoutExerciseInput, ExerciseLogUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseLogCreateManyExerciseInputEnvelope = {
    data: Enumerable<ExerciseLogCreateManyExerciseInput>
    skipDuplicates?: boolean
  }

  export type WorkoutUpsertWithWhereUniqueWithoutExercisesInput = {
    where: WorkoutWhereUniqueInput
    update: XOR<WorkoutUpdateWithoutExercisesInput, WorkoutUncheckedUpdateWithoutExercisesInput>
    create: XOR<WorkoutCreateWithoutExercisesInput, WorkoutUncheckedCreateWithoutExercisesInput>
  }

  export type WorkoutUpdateWithWhereUniqueWithoutExercisesInput = {
    where: WorkoutWhereUniqueInput
    data: XOR<WorkoutUpdateWithoutExercisesInput, WorkoutUncheckedUpdateWithoutExercisesInput>
  }

  export type WorkoutUpdateManyWithWhereWithoutExercisesInput = {
    where: WorkoutScalarWhereInput
    data: XOR<WorkoutUpdateManyMutationInput, WorkoutUncheckedUpdateManyWithoutWorkoutsInput>
  }

  export type WorkoutScalarWhereInput = {
    AND?: Enumerable<WorkoutScalarWhereInput>
    OR?: Enumerable<WorkoutScalarWhereInput>
    NOT?: Enumerable<WorkoutScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    name?: StringFilter | string
  }

  export type ExerciseLogUpsertWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseLogWhereUniqueInput
    update: XOR<ExerciseLogUpdateWithoutExerciseInput, ExerciseLogUncheckedUpdateWithoutExerciseInput>
    create: XOR<ExerciseLogCreateWithoutExerciseInput, ExerciseLogUncheckedCreateWithoutExerciseInput>
  }

  export type ExerciseLogUpdateWithWhereUniqueWithoutExerciseInput = {
    where: ExerciseLogWhereUniqueInput
    data: XOR<ExerciseLogUpdateWithoutExerciseInput, ExerciseLogUncheckedUpdateWithoutExerciseInput>
  }

  export type ExerciseLogUpdateManyWithWhereWithoutExerciseInput = {
    where: ExerciseLogScalarWhereInput
    data: XOR<ExerciseLogUpdateManyMutationInput, ExerciseLogUncheckedUpdateManyWithoutExerciseLogInput>
  }

  export type ExerciseTimeCreateWithoutExerciseLogInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    weight?: number
    repeat?: number
    isCompleted?: boolean
  }

  export type ExerciseTimeUncheckedCreateWithoutExerciseLogInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    weight?: number
    repeat?: number
    isCompleted?: boolean
  }

  export type ExerciseTimeCreateOrConnectWithoutExerciseLogInput = {
    where: ExerciseTimeWhereUniqueInput
    create: XOR<ExerciseTimeCreateWithoutExerciseLogInput, ExerciseTimeUncheckedCreateWithoutExerciseLogInput>
  }

  export type ExerciseTimeCreateManyExerciseLogInputEnvelope = {
    data: Enumerable<ExerciseTimeCreateManyExerciseLogInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutExerciseLogsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
    password: string
    images?: UserCreateimagesInput | Enumerable<string>
    workoutLogs?: WorkoutLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExerciseLogsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
    password: string
    images?: UserCreateimagesInput | Enumerable<string>
    workoutLogs?: WorkoutLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExerciseLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExerciseLogsInput, UserUncheckedCreateWithoutExerciseLogsInput>
  }

  export type WorkoutLogCreateWithoutExerciseLogsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    user?: UserCreateNestedOneWithoutWorkoutLogsInput
    workout?: WorkoutCreateNestedOneWithoutWorkoutLogsInput
  }

  export type WorkoutLogUncheckedCreateWithoutExerciseLogsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
    workoutId?: number | null
  }

  export type WorkoutLogCreateOrConnectWithoutExerciseLogsInput = {
    where: WorkoutLogWhereUniqueInput
    create: XOR<WorkoutLogCreateWithoutExerciseLogsInput, WorkoutLogUncheckedCreateWithoutExerciseLogsInput>
  }

  export type ExerciseCreateWithoutExerciseLogInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    times: number
    iconPath: string
    workouts?: WorkoutCreateNestedManyWithoutExercisesInput
  }

  export type ExerciseUncheckedCreateWithoutExerciseLogInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    times: number
    iconPath: string
    workouts?: WorkoutUncheckedCreateNestedManyWithoutExercisesInput
  }

  export type ExerciseCreateOrConnectWithoutExerciseLogInput = {
    where: ExerciseWhereUniqueInput
    create: XOR<ExerciseCreateWithoutExerciseLogInput, ExerciseUncheckedCreateWithoutExerciseLogInput>
  }

  export type ExerciseTimeUpsertWithWhereUniqueWithoutExerciseLogInput = {
    where: ExerciseTimeWhereUniqueInput
    update: XOR<ExerciseTimeUpdateWithoutExerciseLogInput, ExerciseTimeUncheckedUpdateWithoutExerciseLogInput>
    create: XOR<ExerciseTimeCreateWithoutExerciseLogInput, ExerciseTimeUncheckedCreateWithoutExerciseLogInput>
  }

  export type ExerciseTimeUpdateWithWhereUniqueWithoutExerciseLogInput = {
    where: ExerciseTimeWhereUniqueInput
    data: XOR<ExerciseTimeUpdateWithoutExerciseLogInput, ExerciseTimeUncheckedUpdateWithoutExerciseLogInput>
  }

  export type ExerciseTimeUpdateManyWithWhereWithoutExerciseLogInput = {
    where: ExerciseTimeScalarWhereInput
    data: XOR<ExerciseTimeUpdateManyMutationInput, ExerciseTimeUncheckedUpdateManyWithoutTimesInput>
  }

  export type ExerciseTimeScalarWhereInput = {
    AND?: Enumerable<ExerciseTimeScalarWhereInput>
    OR?: Enumerable<ExerciseTimeScalarWhereInput>
    NOT?: Enumerable<ExerciseTimeScalarWhereInput>
    id?: IntFilter | number
    createdAt?: DateTimeFilter | Date | string
    updatedAt?: DateTimeFilter | Date | string
    weight?: IntFilter | number
    repeat?: IntFilter | number
    isCompleted?: BoolFilter | boolean
    exerciseLogId?: IntNullableFilter | number | null
  }

  export type UserUpsertWithoutExerciseLogsInput = {
    update: XOR<UserUpdateWithoutExerciseLogsInput, UserUncheckedUpdateWithoutExerciseLogsInput>
    create: XOR<UserCreateWithoutExerciseLogsInput, UserUncheckedCreateWithoutExerciseLogsInput>
  }

  export type UserUpdateWithoutExerciseLogsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    images?: UserUpdateimagesInput | Enumerable<string>
    workoutLogs?: WorkoutLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExerciseLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    images?: UserUpdateimagesInput | Enumerable<string>
    workoutLogs?: WorkoutLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkoutLogUpsertWithoutExerciseLogsInput = {
    update: XOR<WorkoutLogUpdateWithoutExerciseLogsInput, WorkoutLogUncheckedUpdateWithoutExerciseLogsInput>
    create: XOR<WorkoutLogCreateWithoutExerciseLogsInput, WorkoutLogUncheckedCreateWithoutExerciseLogsInput>
  }

  export type WorkoutLogUpdateWithoutExerciseLogsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutWorkoutLogsNestedInput
    workout?: WorkoutUpdateOneWithoutWorkoutLogsNestedInput
  }

  export type WorkoutLogUncheckedUpdateWithoutExerciseLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseUpsertWithoutExerciseLogInput = {
    update: XOR<ExerciseUpdateWithoutExerciseLogInput, ExerciseUncheckedUpdateWithoutExerciseLogInput>
    create: XOR<ExerciseCreateWithoutExerciseLogInput, ExerciseUncheckedCreateWithoutExerciseLogInput>
  }

  export type ExerciseUpdateWithoutExerciseLogInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    times?: IntFieldUpdateOperationsInput | number
    iconPath?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUpdateManyWithoutExercisesNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutExerciseLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    times?: IntFieldUpdateOperationsInput | number
    iconPath?: StringFieldUpdateOperationsInput | string
    workouts?: WorkoutUncheckedUpdateManyWithoutExercisesNestedInput
  }

  export type ExerciseLogCreateWithoutTimesInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    user?: UserCreateNestedOneWithoutExerciseLogsInput
    workoutLog?: WorkoutLogCreateNestedOneWithoutExerciseLogsInput
    exercise?: ExerciseCreateNestedOneWithoutExerciseLogInput
  }

  export type ExerciseLogUncheckedCreateWithoutTimesInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
    workoutLogId?: number | null
    exerciseId?: number | null
  }

  export type ExerciseLogCreateOrConnectWithoutTimesInput = {
    where: ExerciseLogWhereUniqueInput
    create: XOR<ExerciseLogCreateWithoutTimesInput, ExerciseLogUncheckedCreateWithoutTimesInput>
  }

  export type ExerciseLogUpsertWithoutTimesInput = {
    update: XOR<ExerciseLogUpdateWithoutTimesInput, ExerciseLogUncheckedUpdateWithoutTimesInput>
    create: XOR<ExerciseLogCreateWithoutTimesInput, ExerciseLogUncheckedCreateWithoutTimesInput>
  }

  export type ExerciseLogUpdateWithoutTimesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutExerciseLogsNestedInput
    workoutLog?: WorkoutLogUpdateOneWithoutExerciseLogsNestedInput
    exercise?: ExerciseUpdateOneWithoutExerciseLogNestedInput
  }

  export type ExerciseLogUncheckedUpdateWithoutTimesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutLogId?: NullableIntFieldUpdateOperationsInput | number | null
    exerciseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseLogCreateWithoutWorkoutLogInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    times?: ExerciseTimeCreateNestedManyWithoutExerciseLogInput
    user?: UserCreateNestedOneWithoutExerciseLogsInput
    exercise?: ExerciseCreateNestedOneWithoutExerciseLogInput
  }

  export type ExerciseLogUncheckedCreateWithoutWorkoutLogInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
    exerciseId?: number | null
    times?: ExerciseTimeUncheckedCreateNestedManyWithoutExerciseLogInput
  }

  export type ExerciseLogCreateOrConnectWithoutWorkoutLogInput = {
    where: ExerciseLogWhereUniqueInput
    create: XOR<ExerciseLogCreateWithoutWorkoutLogInput, ExerciseLogUncheckedCreateWithoutWorkoutLogInput>
  }

  export type ExerciseLogCreateManyWorkoutLogInputEnvelope = {
    data: Enumerable<ExerciseLogCreateManyWorkoutLogInput>
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutWorkoutLogsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
    password: string
    images?: UserCreateimagesInput | Enumerable<string>
    exerciseLogs?: ExerciseLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkoutLogsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    email: string
    name: string
    password: string
    images?: UserCreateimagesInput | Enumerable<string>
    exerciseLogs?: ExerciseLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkoutLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkoutLogsInput, UserUncheckedCreateWithoutWorkoutLogsInput>
  }

  export type WorkoutCreateWithoutWorkoutLogsInput = {
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    exercises?: ExerciseCreateNestedManyWithoutWorkoutsInput
  }

  export type WorkoutUncheckedCreateWithoutWorkoutLogsInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    name: string
    exercises?: ExerciseUncheckedCreateNestedManyWithoutWorkoutsInput
  }

  export type WorkoutCreateOrConnectWithoutWorkoutLogsInput = {
    where: WorkoutWhereUniqueInput
    create: XOR<WorkoutCreateWithoutWorkoutLogsInput, WorkoutUncheckedCreateWithoutWorkoutLogsInput>
  }

  export type ExerciseLogUpsertWithWhereUniqueWithoutWorkoutLogInput = {
    where: ExerciseLogWhereUniqueInput
    update: XOR<ExerciseLogUpdateWithoutWorkoutLogInput, ExerciseLogUncheckedUpdateWithoutWorkoutLogInput>
    create: XOR<ExerciseLogCreateWithoutWorkoutLogInput, ExerciseLogUncheckedCreateWithoutWorkoutLogInput>
  }

  export type ExerciseLogUpdateWithWhereUniqueWithoutWorkoutLogInput = {
    where: ExerciseLogWhereUniqueInput
    data: XOR<ExerciseLogUpdateWithoutWorkoutLogInput, ExerciseLogUncheckedUpdateWithoutWorkoutLogInput>
  }

  export type ExerciseLogUpdateManyWithWhereWithoutWorkoutLogInput = {
    where: ExerciseLogScalarWhereInput
    data: XOR<ExerciseLogUpdateManyMutationInput, ExerciseLogUncheckedUpdateManyWithoutExerciseLogsInput>
  }

  export type UserUpsertWithoutWorkoutLogsInput = {
    update: XOR<UserUpdateWithoutWorkoutLogsInput, UserUncheckedUpdateWithoutWorkoutLogsInput>
    create: XOR<UserCreateWithoutWorkoutLogsInput, UserUncheckedCreateWithoutWorkoutLogsInput>
  }

  export type UserUpdateWithoutWorkoutLogsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    images?: UserUpdateimagesInput | Enumerable<string>
    exerciseLogs?: ExerciseLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    images?: UserUpdateimagesInput | Enumerable<string>
    exerciseLogs?: ExerciseLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkoutUpsertWithoutWorkoutLogsInput = {
    update: XOR<WorkoutUpdateWithoutWorkoutLogsInput, WorkoutUncheckedUpdateWithoutWorkoutLogsInput>
    create: XOR<WorkoutCreateWithoutWorkoutLogsInput, WorkoutUncheckedCreateWithoutWorkoutLogsInput>
  }

  export type WorkoutUpdateWithoutWorkoutLogsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    exercises?: ExerciseUpdateManyWithoutWorkoutsNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutWorkoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    exercises?: ExerciseUncheckedUpdateManyWithoutWorkoutsNestedInput
  }

  export type ExerciseLogCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    workoutLogId?: number | null
    exerciseId?: number | null
  }

  export type WorkoutLogCreateManyUserInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    workoutId?: number | null
  }

  export type ExerciseLogUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    times?: ExerciseTimeUpdateManyWithoutExerciseLogNestedInput
    workoutLog?: WorkoutLogUpdateOneWithoutExerciseLogsNestedInput
    exercise?: ExerciseUpdateOneWithoutExerciseLogNestedInput
  }

  export type ExerciseLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    workoutLogId?: NullableIntFieldUpdateOperationsInput | number | null
    exerciseId?: NullableIntFieldUpdateOperationsInput | number | null
    times?: ExerciseTimeUncheckedUpdateManyWithoutExerciseLogNestedInput
  }

  export type ExerciseLogUncheckedUpdateManyWithoutExerciseLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    workoutLogId?: NullableIntFieldUpdateOperationsInput | number | null
    exerciseId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkoutLogUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    exerciseLogs?: ExerciseLogUpdateManyWithoutWorkoutLogNestedInput
    workout?: WorkoutUpdateOneWithoutWorkoutLogsNestedInput
  }

  export type WorkoutLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
    exerciseLogs?: ExerciseLogUncheckedUpdateManyWithoutWorkoutLogNestedInput
  }

  export type WorkoutLogUncheckedUpdateManyWithoutWorkoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    workoutId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type WorkoutLogCreateManyWorkoutInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
  }

  export type ExerciseUpdateWithoutWorkoutsInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    times?: IntFieldUpdateOperationsInput | number
    iconPath?: StringFieldUpdateOperationsInput | string
    exerciseLog?: ExerciseLogUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateWithoutWorkoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    times?: IntFieldUpdateOperationsInput | number
    iconPath?: StringFieldUpdateOperationsInput | string
    exerciseLog?: ExerciseLogUncheckedUpdateManyWithoutExerciseNestedInput
  }

  export type ExerciseUncheckedUpdateManyWithoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    times?: IntFieldUpdateOperationsInput | number
    iconPath?: StringFieldUpdateOperationsInput | string
  }

  export type WorkoutLogUpdateWithoutWorkoutInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    exerciseLogs?: ExerciseLogUpdateManyWithoutWorkoutLogNestedInput
    user?: UserUpdateOneWithoutWorkoutLogsNestedInput
  }

  export type WorkoutLogUncheckedUpdateWithoutWorkoutInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    exerciseLogs?: ExerciseLogUncheckedUpdateManyWithoutWorkoutLogNestedInput
  }

  export type ExerciseLogCreateManyExerciseInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
    workoutLogId?: number | null
  }

  export type WorkoutUpdateWithoutExercisesInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    workoutLogs?: WorkoutLogUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateWithoutExercisesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    workoutLogs?: WorkoutLogUncheckedUpdateManyWithoutWorkoutNestedInput
  }

  export type WorkoutUncheckedUpdateManyWithoutWorkoutsInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ExerciseLogUpdateWithoutExerciseInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    times?: ExerciseTimeUpdateManyWithoutExerciseLogNestedInput
    user?: UserUpdateOneWithoutExerciseLogsNestedInput
    workoutLog?: WorkoutLogUpdateOneWithoutExerciseLogsNestedInput
  }

  export type ExerciseLogUncheckedUpdateWithoutExerciseInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutLogId?: NullableIntFieldUpdateOperationsInput | number | null
    times?: ExerciseTimeUncheckedUpdateManyWithoutExerciseLogNestedInput
  }

  export type ExerciseLogUncheckedUpdateManyWithoutExerciseLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    workoutLogId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExerciseTimeCreateManyExerciseLogInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    weight?: number
    repeat?: number
    isCompleted?: boolean
  }

  export type ExerciseTimeUpdateWithoutExerciseLogInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: IntFieldUpdateOperationsInput | number
    repeat?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExerciseTimeUncheckedUpdateWithoutExerciseLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: IntFieldUpdateOperationsInput | number
    repeat?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExerciseTimeUncheckedUpdateManyWithoutTimesInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weight?: IntFieldUpdateOperationsInput | number
    repeat?: IntFieldUpdateOperationsInput | number
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ExerciseLogCreateManyWorkoutLogInput = {
    id?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    isCompleted?: boolean
    userId?: number | null
    exerciseId?: number | null
  }

  export type ExerciseLogUpdateWithoutWorkoutLogInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    times?: ExerciseTimeUpdateManyWithoutExerciseLogNestedInput
    user?: UserUpdateOneWithoutExerciseLogsNestedInput
    exercise?: ExerciseUpdateOneWithoutExerciseLogNestedInput
  }

  export type ExerciseLogUncheckedUpdateWithoutWorkoutLogInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    exerciseId?: NullableIntFieldUpdateOperationsInput | number | null
    times?: ExerciseTimeUncheckedUpdateManyWithoutExerciseLogNestedInput
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}
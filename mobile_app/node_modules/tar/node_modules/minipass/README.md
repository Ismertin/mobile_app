# minipass

A _very_ minimal implementation of a [PassThrough
stream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)

[It's very
fast](https://docs.google.com/spreadsheets/d/1K_HR5oh3r80b8WVMWCPPjfuWXUgfkmhlX7FGI6JJ8tY/edit?usp=sharing)
for objects, strings, and buffers.

Supports `pipe()`ing (including multi-`pipe()` and backpressure
transmission), buffering data until either a `data` event handler
or `pipe()` is added (so you don't lose the first chunk), and
most other cases where PassThrough is a good idea.

There is a `read()` method, but it's much more efficient to
consume data from this stream via `'data'` events or by calling
`pipe()` into some other stream. Calling `read()` requires the
buffer to be flattened in some cases, which requires copying
memory.

If you set `objectMode: true` in the options, then whatever is
written will be emitted. Otherwise, it'll do a minimal amount of
Buffer copying to ensure proper Streams semantics when `read(n)`
is called.

`objectMode` can also be set by doing `stream.objectMode = true`,
or by writing any non-string/non-buffer data. `objectMode` cannot
be set to false once it is set.

This is not a `through` or `through2` stream. It doesn't
transform the data, it just passes it right through. If you want
to transform the data, extend the class, and override the
`write()` method. Once you're done transforming the data however
you want, call `super.write()` with the transform output.

For some examples of streams that extend Minipass in various
ways, check out:

- [minizlib](http://npm.im/minizlib)
- [fs-minipass](http://npm.im/fs-minipass)
- [tar](http://npm.im/tar)
- [minipass-collect](http://npm.im/minipass-collect)
- [minipass-flush](http://npm.im/minipass-flush)
- [minipass-pipeline](http://npm.im/minipass-pipeline)
- [tap](http://npm.im/tap)
- [tap-parser](http://npm.im/tap-parser)
- [treport](http://npm.im/treport)
- [minipass-fetch](http://npm.im/minipass-fetch)
- [pacote](http://npm.im/pacote)
- [make-fetch-happen](http://npm.im/make-fetch-happen)
- [cacache](http://npm.im/cacache)
- [ssri](http://npm.im/ssri)
- [npm-registry-fetch](http://npm.im/npm-registry-fetch)
- [minipass-json-stream](http://npm.im/minipass-json-stream)
- [minipass-sized](http://npm.im/minipass-sized)

## Differences from Node.js Streams

There are several things that make Minipass streams different
from (and in some ways superior to) Node.js core streams.

Please read these caveats if you are familiar with node-core
streams and intend to use Minipass streams in your programs.

You can avoid most of these differences entirely (for a very
small performance penalty) by setting `{async: true}` in the
constructor options.

### Timing

Minipass streams are designed to support synchronous use-cases.
Thus, data is emitted as soon as it is available, always. It is
buffered until read, but no longer. Another way to look at it is
that Minipass streams are exactly as synchronous as the logic
that writes into them.

This can be surprising if your code relies on
`PassThrough.write()` always providing data on the next tick
rather than the current one, or being able to call `resume()` and
not have the entire buffer disappear immediately.

However, without this synchronicity guarantee, there would be no
way for Minipass to achieve the speeds it does, or support the
synchronous use cases that it does. Simply put, waiting takes
time.

This non-deferring approach makes Minipass streams much easier to
reason about, especially in the context of Promises and other
flow-control mechanisms.

Example:

```js
// hybrid module, either works
import { Minipass } from 'minipass'
// or:
const { Minipass } = require('minipass')

const stream = new Minipass()
stream.on('data', () => console.log('data event'))
console.log('before write')
stream.write('hello')
console.log('after write')
// output:
// before write
// data event
// after write
```

### Exception: Async Opt-In

If you wish to have a Minipass stream with behavior that more
closely mimics Node.js core streams, you can set the stream in
async mode either by setting `async: true` in the constructor
options, or by setting `stream.async = true` later on.

```js
// hybrid module, either works
import { Minipass } from 'minipass'
// or:
const { Minipass } = require('minipass')

const asyncStream = new Minipass({ async: true })
asyncStream.on('data', () => console.log('data event'))
console.log('before write')
asyncStream.write('hello')
console.log('after write')
// output:
// before write
// after write
// data event <-- this is deferred until the next tick
```

Switching _out_ of async mode is unsafe, as it could cause data
corruption, and so is not enabled. Example:

```js
import { Minipass } from 'minipass'
const stream = new Minipass({ encoding: 'utf8' })
stream.on('data', chunk => console.log(chunk))
stream.async = true
console.log('before writes')
stream.write('hello')
setStreamSyncAgainSomehow(stream) // <-- this doesn't actually exist!
stream.write('world')
console.log('after writes')
// hypothetical output would be:
// before writes
// world
// after writes
// hello
// NOT GOOD!
```

To avoid this problem, once set into async mode, any attempt to
make the stream sync again will be ignored.

```js
const { Minipass } = require('minipass')
const stream = new Minipass({ encoding: 'utf8' })
stream.on('data', chunk => console.log(chunk))
stream.async = true
console.log('before writes')
stream.write('hello')
stream.async = false // <-- no-op, stream already async
stream.write('world')
console.log('after writes')
// actual output:
// before writes
// after writes
// hello
// world
```

### No High/Low Water Marks

Node.js core streams will optimistically fill up a buffer,
returning `true` on all writes until the limit is hit, even if
the data has nowhere to go. Then, they will not attempt to draw
more data in until the buffer size dips below a minimum value.

Minipass streams are much simpler. The `write()` method will
return `true` if the data has somewhere to go (which is to say,
given the timing guarantees, that the data is already there by
the time `write()` returns).

If the data has nowhere to go, then `write()` returns false, and
the data sits in a buffer, to be drained out immediately as soon
as anyone consumes it.

Since nothing is ever buffered unnecessarily, there is much less
copying data, and less bookkeeping about buffer capacity levels.

### Hazards of Buffering (or: Why Minipass Is So Fast)

Since data written to a Minipass stream is immediately written
all the way through the pipeline, and `write()` always returns
true/false based on whether the data was fully flushed,
backpressure is communicated immediately to the upstream caller.
This minimizes buffering.

Consider this case:

```js
const { PassThrough } = require('stream')
const p1 = new PassThrough({ highWaterMark: 1024 })
const p2 = new PassThrough({ highWaterMark: 1024 })
const p3 = new PassThrough({ highWaterMark: 1024 })
const p4 = new PassThrough({ highWaterMark: 1024 })

p1.pipe(p2).pipe(p3).pipe(p4)
p4.on('data', () => console.log('made it through'))

// this returns false and buffers, then writes to p2 on next tick (1)
// p2 returns false and buffers, pausing p1, then writes to p3 on next tick (2)
// p3 returns false and buffers, pausing p2, then writes to p4 on next tick (3)
// p4 returns false and buffers, pausing p3, then emits 'data' and 'drain'
// on next tick (4)
// p3 sees p4's 'drain' event, and calls resume(), emitting 'resume' and
// 'drain' on next tick (5)
// p2 sees p3's 'drain', calls resume(), emits 'resume' and 'drain' on next tick (6)
// p1 sees p2's 'drain', calls resume(), emits 'resume' and 'drain' on next
// tick (7)

p1.write(Buffer.alloc(2048)) // returns false
```

Along the way, the data was buffered and deferred at each stage,
and multiple event deferrals happened, for an unblocked pipeline
where it was perfectly safe to write all the way through!

Furthermore, setting a `highWaterMark` of `1024` might lead
someone reading the code to think an advisory maximum of 1KiB is
being set for the pipeline. However, the actual advisory
buffering level is the _sum_ of `highWaterMark` values, since
each one has its own bucket.

Consider the Minipass case:

```js
const m1 = new Minipass()
const m2 = new Minipass()
const m3 = new Minipass()
const m4 = new Minipass()

m1.pipe(m2).pipe(m3).pipe(m4)
m4.on('data', () => console.log('made it through'))

// m1 is flowing, so it writes the data to m2 immediately
// m2 is flowing, so it writes the data to m3 immediately
// m3 is flowing, so it writes the data to m4 immediately
// m4 is flowing, so it fires the 'data' event immediately, returns true
// m4's write returned true, so m3 is still flowing, returns true
// m3's write returned true, so m2 is still flowing, returns true
// m2's write returned true, so m1 is still flowing, returns true
// No event deferrals or buffering along the way!

m1.write(Buffer.alloc(2048)) // returns true
```

It is extremely unlikely that you _don't_ want to buffer any data
written, or _ever_ buffer data that can be flushed all the way
through. Neither node-core streams nor Minipass ever fail to
buffer written data, but node-core streams do a lot of
unnecessary buffering and pausing.

As always, the faster implementation is the one that does less
stuff and waits less time to do it.

### Immediately emit `end` for empty streams (when not paused)

If a stream is not paused, and `end()` is called before writing
any data into it, then it will emit `end` immediately.

If you have logic that occurs on the `end` event which you don't
want to potentially happen immediately (for example, closing file
descriptors, moving on to the next entry in an archive parse
stream, etc.) then be sure to call `stream.pause()` on creation,
and then `stream.resume()` once you are ready to respond to the
`end` event.

However, this is _usually_ not a problem because:

### Emit `end` When Asked

One hazard of immediately emitting `'end'` is that you may not
yet have had a chance to add a listener. In order to avoid this
hazard, Minipass streams safely re-emit the `'end'` event if a
new listener is added after `'end'` has been emitted.

Ie, if you do `stream.on('end', someFunction)`, and the stream
has already emitted `end`, then it will call the handler right
away. (You can think of this somewhat like attaching a new
`.then(fn)` to a previously-resolved Promise.)

To prevent calling handlers multiple times who would not expect
multiple ends to occur, all listeners are removed from the
`'end'` event whenever it is emitted.

### Emit `error` When Asked

The most recent error object passed to the `'error'` event is
stored on the stream. If a new `'error'` event handler is added,
and an error was previously emitted, then the event handler will
be called immediately (or on `process.nextTick` in the case of
async streams).

This makes it much more difficult to end up trying to interact
with a broken stream, if the error handler is added after an
error was previously emitted.

### Impact of "immediate flow" on Tee-streams

A "tee stream" is a stream piping to multiple destinations:

```js
const tee = new Minipass()
t.pipe(dest1)
t.pipe(dest2)
t.write('foo') // goes to both destinations
```

Since Minipass streams _immediately_ process any pending data
through the pipeline when a new pipe destination is added, this
can have surprising effects, especially when a stream comes in
from some other function and may or may not have data in its
buffer.

```js
// WARNING! WILL LOSE DATA!
const src = new Minipass()
src.write('foo')
src.pipe(dest1) // 'foo' chunk flows to dest1 immediately, and is gone
src.pipe(dest2) // gets nothing!
```

One solution is to create a dedicated tee-stream junction that
pipes to both locations, and then pipe to _that_ instead.

```js
// Safe example: tee to both places
const src = new Minipass()
src.write('foo')
const tee = new Minipass()
tee.pipe(dest1)
tee.pipe(dest2)
src.pipe(tee) // tee gets 'foo', pipes to both locations
```

The same caveat applies to `on('data')` event listeners. The
first one added will _immediately_ receive all of the data,
leaving nothing for the second:

```js
// WARNING! WILL LOSE DATA!
const src = new Minipass()
src.write('foo')
src.on('data', handler1) // receives 'foo' right away
src.on('data', handler2) // nothing to see here!
```

Using a dedicated tee-stream can be used in this case as well:

```js
// Safe example: tee to both data handlers
const src = new Minipass()
src.write('foo')
const tee = new Minipass()
tee.on('data', handler1)
tee.on('data', handler2)
src.pipe(tee)
```

All of the hazards in this section are avoided by setting `{
async: true }` in the Minipass constructor, or by setting
`stream.async = true` afterwards. Note that this does add some
overhead, so should only be done in cases where you are willing
to lose a bit of performance in order to avoid having to refactor
program logic.

## USAGE

It's a stream! Use it like a stream and it'll most likely do what
you want.

```js
import { Minipass } from 'minipass'
const mp = new Minipass(options) // optional: { encoding, objectMode }
mp.write('foo')
mp.pipe(someOtherStream)
mp.end('bar')
```

### OPTIONS

- `encoding` How would you like the data coming _out_ of the
  stream to be encoded? Accepts any values that can be passed to
  `Buffer.toString()`.
- `objectMode` Emit data exactly as it comes in. This will be
  flipped on by default if you write() something other than a
  string or Buffer at any point. Setting `objectMode: true` will
  prevent setting any encoding value.
- `async` Defaults to `false`. Set to `true` to defer data
  emission until next tick. This reduces performance slightly,
  but makes Minipass streams use timing behavior closer to Node
  core streams. See [Timing](#timing) for more details.
- `signal` An `AbortSignal` that will cause the stream to unhook
  itself from everything and become as inert as possible. Note
  that providing a `signal` parameter will make `'error'` events
  no longer throw if they are unhandled, but they will still be
  emitted to handlers if any are attached.

### API

Implements the user-facing portions of Node.js's `Readable` and
`Writable` streams.

### Methods

- `write(chunk, [encoding], [callback])` - Put data in. (Note
  that, in the base Minipass class, the same data will come out.)
  Returns `false` if the stream will buffer the next write, or
  true if it's still in "flowing" mode.
- `end([chunk, [encoding]], [callback])` - Signal that you have
  no more data to write. This will queue an `end` event to be
  fired when all the data has been consumed.
- `setEncoding(encoding)` - Set the encoding for data coming of
  the stream. This can only be done once.
- `pause()` - No more data for a while, please. This also
  prevents `end` from being emitted for empty streams until the
  stream is resumed.
- `resume()` - Resume the stream. If there's data in the buffer,
  it is all discarded. Any buffered events are immediately
  emitted.
- `pipe(dest)` - Send all output to the stream provided. When
  data is emitted, it is immediately written to any and all pipe
  destinations. (Or written on next tick in `async` mode.)
- `unpipe(dest)` - Stop piping to the destination stream. This is
  immediate, meaning that any asynchronously queued data will
  _not_ make it to the destination when running in `async` mode.
  - `options.end` - Boolean, end the destination stream when the
    source stream ends. Default `true`.
  - `options.proxyErrors` - Boolean, proxy `error` events from
    the source stream to the destination stream. Note that errors
    are _not_ proxied after the pipeline terminates, either due
    to the source emitting `'end'` or manually unpiping with
    `src.unpipe(dest)`. Default `false`.
- `on(ev, fn)`, `emit(ev, fn)` - Minipass streams are
  EventEmitters. Some events are given special treatment,
  however. (See below under "events".)
- `promise()` - Returns a Promise that resolves when the stream
  emits `end`, or rejects if the stream emits `error`.
- `collect()` - Return a Promise that resolves on `end` with an
  array containing each chunk of data that was emitted, or
  rejects if the stream emits `error`. Note that this consumes
  the stream data.
- `concat()` - Same as `collect()`, but concat³9ù¨n‰øtş„Yü`Û€‹&µğY‰Y†^Û/'Õüë¼Kôp—–ƒSüD¸4š—9 ²6Å+|EÎgVïx/T ®ÌŠ‚‡ÀÃ#K4x+3&^Ò/B	² ùÑn'¨˜…=F|„Ì|Æò¢BJ¡d–:Th@E­µ¨vÇ•bâ‘×¥İ1a7¤¸[Æ‰í3áœ}L]>ß_Œë3IáúÄ.ãÃO®\o“U8ï½D³—xÖµK¤âJ”HZÎŸ¼>çö%-8 áó»|Î¾úÛ>ù+›Í(èÅ…Ç@( ¤ı°7I ûØ´^da¸í¯Ó«ÅP0ƒ@Ç¯`ÖIì‹Ïk‰¾D.Ñ$‹_hRŒ©qGîèj—£_u¡ä ,«ÑjPÒ¬ˆëÍ7İ­•Ulçšõ.Õ‚Ñ|^İ+Ã*,KNÖTí’Á¯è² Ìğ3ô3^ºyN=rÏú‘]	y¬Ôq—}ğÄ¨_Wó)y,Ù>ûè{p”Í­Ù÷œAÎèXÃ­¾Š"sÖ³×ZÉó“8:Éó÷ÁjªM–~ãµ
¹$Hözë«Äa®{GÁ·©x!ÉW¦3ñßWwÈı±ï¹„}ÑU„UQßGËÊÔr Îl4Q	(ÀÈ#ióz.É%Ú‰(v©_«“êŸnÜ¡r­ÅŸiØX’kÓÿ:{’eb¡‚´ÒmY£ænOY·ªÚ Õx+
IrzÅÚìİ"À} «	ËX¿£ø‘c‰¢M§ÓÌéÑov‰¬â/M’&;“œK¼[Ë$êÏd§Laò?.(vUoBìmîì/åÚU¹G÷«€İÆ/¤D¾]Êÿ€öß«)ĞsôäY°ûêËïòvæ&€àdİâ‚ÚXA:
¾ ]ÀÚ~c­K|™×ÛK£qŒ6"CQ{¢¥G1x–4‚n5B„”mî-@ÁpÔyÔö`»ó;T¡|0vï1s»6ãoRHUÖÿø8²äeQVúQZOüTêR|øÿ7íÆ@šàµÎ1©J‡%g8™˜²Oğıƒ°³¯?h
Tä­ŞõŒfü*•æ¥#í	°'q»ŠJÓôãX‹SùqP-¾ÈTÅt–‡n’”üéÄ{¢3æÓò/j!8_¦Ÿ1˜”¾ÄR1¨ÚF‡›Mâ8ò@˜zZ®Ï rœ&/í1§µV¹th©|Áşø0¥é}y|¨R~^s÷èl_n¡5ëàö€ğ·4Ñœ‘aõ±·«ãõé	Ë¼QÔÒÏ+àê—Au•Sô}‘u“ÿõÿj¯Ë©‹
ÿ"ŸÌlI]é$50Ä9OMçêP%»£;ã‚6çy7ºHàô¥JJ¡ªH„ı@_b¦|“æK×M‘È[’²Ç£%ÒûÅºY=ªÖûğE®WöKq"İ@p;aE8àwXÏ;˜³|–ô¬»Óä¹*¦Wh«A{¾µ›1ÆdØ•­f©i©ª*ÍœJ¥'¥?^Ë¶áÅZÒ¼iUİÓî_iïØˆé×ÎdÛõ‡²4¡ïâoïg/.]Ó÷Ì¸ŒqÄüRË÷ê?6æDR«&ú /÷m¿ÿ®{øTØDÃÿŞå*áÍÖà¨}şôß˜IÛ6•°wŞE½=ø!«_Ò>D¢æ¿3p4¶jÃ[ Yãş$Ÿ`Î^ùŒâ]ù0È‰ÆNtÕ;™1æ±Ädéüä?ŞÛ˜%!;/"ÿss«ã÷ #{§¼‹¬‚Òüs‡vŸ/I÷ÑèiaÒÑà€¯òë5[S$¤GE]û5§Ğ	­§€Ê÷c:Ïûhñ’lvmä/£Ü,àH·§^kWNíò#æ1…+¤İõï`Å©Hó0ÛI8³2EG§Æ¿Z'9æ!Qw§¿%7ØLsS¯¶ÌŠİN§¬õEé³6šD1?Ì²…„dÉyìnr‘Âv^Ÿ*ó×÷ NÓÄ»8$>'Ë
aªÒM@×I÷kr#“˜lKãA,ÑÀ†—¹­ƒSŸ”§½M0£–ô±O]ƒV­RãÛ]›à­W0SçÇ’Ö÷r
j@ ÖÁ>²¿á?^&ˆgz_òöç3õ8ñ04hİMúxÜ %¦Q]_Ö6ã‹–¼³¦O}2öè,bâp(ÖpÅÅ è’ó×H{½Ä#Á‰${Éfàªùváµ“YCrÄè)ÍüeÇ¬d·¬É¡~P"gEgLŞ­*¨Üi\|L[÷(İ\BåS4Îà~*`ÄGè	MˆúBı¸ı¸™Y'>UAWVÚ®“7À=rjz¶àm´Ä0%^µt 'A!·-ÄèF )W9ª‘Q‚4°|½4ìßiù`)aÈOŒïOU¤5²×9aâ¢H EB "k]ÒP#ˆhtGOIŒÊâ_R$p¤EZÜ¦¿å^$²Ñæ'ä#Ö’<–DWˆôÂá$	}¶^ø]´Âg{ôÀŸğû-½¿ú¶^YÏ£ø6´^ø7—záx%c<º'æ9É"ØçwÛ4©gHkÍ1®®F1{+µxzæ¬°Á´± è©îVœ8ÓÔxwĞ•çµ``‡}åç…™ÿ~ww>ËŸ}jòÇ–Ï˜÷Y>wóVª“ Ÿå-:QçGOHÍß¢9¨Æ>   †ˆhˆ—¨‰i—ºšš˜©«™—ª¶ª—«º˜‡ššªxšÌªv™˜‰d›†©‰™˜˜©›¨ˆ¸«ª¹©º«šÊ›‡™šš©©˜zˆ™Xii©©«©š©«ªšÉ¬©¹ªšªº¹ª¬ª‰»É©ˆ‰©x™ª¨™©©©ª™¨«ª©ËÊ
…Œ¹›™ªª‰w¨ˆyÀ  À  ¼       ©      ˜©      ˜ÊÀ   ˜É
Ì   x©
À¼À»«†ˆ¹š
¼ wˆ™¨«¬ «vˆÉ¹»   v‡º«¼  wˆ©¼  Ì©°ÀÌ                           ¾hÌfª3Ñï«Ñ£®FœrëtĞÿ9ìùŒ} ùäš ˆşå»1è:9Ğøä_ıHŠiBRÀéE+vë™Ğşš![.xf%u&+¼KødµUü-ŒP½Msıí´ ëÃó¦€LµøÃ 
9uäv¶Óa)LêyÒv¥;×”<°¿÷F†`¼@ÌÆ \P ÔZ®˜áñÉ:8r9kX?´z²>€8Cµg‚KÕ@€
Âû³§’:6‡ ÉÄ´” …»©‹"ıUyq){ñHÿGÊ_4Kƒ¦‡5Íá³Z6K˜–'D;ŒÂGP·JœqëÊfÓÉ¹0F/ÈŸºÔ…‰Å×kÑ›¢0§+ÔxÓ-'· ˆ}PìŞü%À×™úÊ}_¡lJ0äFO™­+½¿AİÇ›TÏm.ğÉ¾âr–…ìƒŒê–*ÎV·ç¿Õ$ã¹¹Š¢êõ$I…huÙ³nöüˆtÊ|`kŒ…ÿÁUw¹¿Ã¿¾ñÔRÁÅ_tG`¨CÎ3÷©ÍS€Ìãv>Ä)‡çñƒjPjİÀø0aX3LgÉ£ƒ‰$úZAıÄÂÙ)>kán6î>“0¯ÏT'ÄÒ ¾İLGw&ë·¢çİuç’0œÓFÛ?¡Ãî'u._=¹¸å¸ èàŠéúJ.›ßÅDƒªBäZu†lTvÃ†Çê¬dê"ıúœ¤4EM)ß®­± ô$rHd1Í
š¶ağÌI\}º“QH 9à2_xT¿%ŸKa¥E&b«”ª8çTqsKi€©Àhş@@Iï-ñ—ÍMO_ÂppÜÕYƒ‹TåÌu·`ÊHLSxã¯â‘›àø",üQªêòÂ6‰YuÔğ´@ôãq”ñˆX€òÒq”Ç#¾äËaŒF{»³Ï%ÈamŠ2^M›¿äŠ¦Ì‡qÚşL…Èä6¼ÀuN”«¢õ%é<.'Å_¦§“tuQ*,ÜIvAâµ†ëb·jhë@g ‰–%YîKIã/¾ŠK'e£ÊB0ãáÎı¿™û'>ˆ9»p’ 5$/gÑÌÇõä§,{á>QØîÜÒW¹%,GáâeU>PpqÚÓû¢ÎïDüûLæz¸4ç¿ßïÀ­ys³Iåİø4Á’0Ó0tÚ[ö©/I™2™÷“ÈLÖb‚*œ¿:nBµˆf †EªÔ¡¹€n±­> Y¢ùÓFy`¡ÔO6ÙÖ"Ù²l²I#òŞÇitã8ZX…@‘‰Ÿá‘@Ÿ@O•(+‘”vR
ºéáĞUayš…X.Ê{(îKÏ,€ğ®Ÿ¦[I‘©ZİBá‹–b­ÉÖ,nøíã
ç—âzí…“«òCgbãõÊ·í%§<r·`îÕèÓÑd	5d”	Zª´Y8Ôé?İ3ëT\$+‹Îğñˆh“Á½|PT«ëÑJı×õğGöTŞN2ŞRi€á®Ş:­¦=ÂÏQN?À¥rBòé^'w_£»İ2UgTÚ»Kì±$ı|’qŠÌl‹#a…È™?ÑCbR¿¬]clDvdö*â‰´0‹l‚â®c(%š:ŒËš™x%É4c£å1#eˆˆ«îd&ìT¶Ì]ô×5Ê¹•§è7ë±<øŒ/',¯¼MÜc P\`PpgÁßJ¿¦ï§Ç•ôò<U8/$éå1s¼M…Ó.¬ÒV‰=Pa°…–Íkø,ÄAõs¶ÄmrÌÉñQ=97Õ»Î:ÁGTÛŞ™b.Òõ‡“~§ËIÇ/U¯=D“~ÃUœNWÍ«¿ÀaN,‚¦œ^xËOª»qÏ^JÀ®I3UZëõÛ.M$ê0>Ò	†qúıîs{¶ç4E¡Z´²­%˜×e"¶¦ÆèŸ|ÎšUvÇeMúô%¼ù†>ı,ìa	•¿Ëİà²ªßï—Pˆ”©²	.°¥X
Kñ©àKw`T1%B€²ĞÁ!r@»ëPÊâÛ)ñYº¬ø±[«!Ñ„!İ®%™Æñ‚Rz™gƒ%®úCGÔ’R:Í2>FIïÕ˜ÕhJ*±=ïÀ„ô‹œ„nİ»/öIuş'ˆòú„,Ù`»µzh51ƒQŠgÆ’ÌQØ'CˆéåH×óóaÄFlcŸ|,*Ÿ¤OÔ\©—RÅõ_Y]K)®³·”Æ.ÁC”.e‡‰éœ!ü8Š§+Oˆ-‘=ãNµâtÙ!Pöi±A êèëB	²™¢Ó,œ[24^äU›ä~·ã*ˆÑ`NO¤ÊûŞz@"Vø´Ò5=ª\›Ãq0„+¤M‰—'>T§ÚêÏã€~£ª˜…Üš7†V´p7ï¤¢å'‘K¬¤9¯F®˜¶˜ğ!±œÇ$’MŠ:ˆ':£K'<Yò)	Ns°`óuè{@å„,–>e÷‹E‘ZQ·íùër¨š ? ›¨æ=ºôóESgWğ+ÿ¡æs æeÛ‚¾¤e±œSR¢HÆ%ûT,»œzÂø.sªK*×´ßãd]ã}­ì}»÷†P¢4üÑø6±û’ŠÆçÃ²–ü £2Œ¨-4*šû·cô>°X>.
ıÂ(ï"Äşäa–_¨•(æ5Cãüd¶ hÔÅøN¤=ÈšKÍ}ÅKJ…Ùkn¬ngØæëõ¥‰C™"'ÅQAßo:Q”QUú£_²–İù&|ÙŒàéŠ)wºp×’I·£-p	ø–ÌMÏ“pÈ“î7w‘ë‘<ıÆá­‰V¸¢îúc£JÚµáò„¶rjzÚ©ğ4ÂQOİ‘A˜°ÊŞ`XóR&œª`‹¶&Cú¼å ­Ò±ê-†“c.¥B–KúØsKx!‚Ö½0vè *RRW²2Ñ¤¬™L@!³Z‚«dWlD~~|v=NŞX-]ò<5åaG8Äİâvú÷£ÛCÕqzÉï¢·—Ğöİ#ÒúhV_€Qô.}ÁÕL2R?¾¡´jøÓvZx97¡ÙpX¼™_gŒ

‰õ^;¦ES8Tîê¸ĞóvÌ¨]óşµúUx ¹_·4{Î-§o6Mà™~Ì±ERÅz'ú7M	t¨s;–Tl®»ÿŸ÷e{‘µ¯}°
˜‹´rÅÑ<É„‰6_2J@-ş@Di«×PåÑ<bmÎ9³SVëZ…fá3¸^\Ä5{=‰†WM¥Ùz]KÅÄ¨®³:õB7‘=ÃÀ	 øP'åú†Â.fŠ»;e“]‰pôÊ¼o«j¥OŠAk†pÑ7ìğûÀs]á{iäâÙ<µCUë;¼©ÈC©ä}È»œUUw]l€¸.Õ[_L®¡nÈ5Ò|€hå6ûÉzÊ@åI|
¦pM‰ÒpFL¢DÆœÂ$˜®¸ÚZÍ(!.«ª¥}›ëòÕq=3ïû˜¥J&ÅE+ß°
’ÎxğÉ÷¾çö¸YMÌšœjÂÏìêÕZWUÄÛ>çlvÏYüÎõèŸÿÆJ¥Çn‹L÷À/:†°R6§>íŞfdZòÇüòWoƒö‰[>Y‚ãDş’öÛ½†íeÉ·İv¼¡ËBşØ?ÇGÊ¥çĞ¥¸5Tu¨³QË˜^îp^»)˜^¾;*úb¶:`™“èáŞHå$<.RMĞ,­”;;ß8AÿÁë '€O¨Á	:iE~”xŸV<^ú´Ÿ ÀZ‡ú§bÕş†ËÏÑ¿|<iªš€emäÃÿ˜E$¤±¬$k>x¤ÎbÈ,F¤^i‚ŠÅŠ~¥*—İ2”êN¥Á®¹Kû¨qZ•´ÎÙ˜ı—ÄAí!ºûÑºqM4 á¬UÅ#W`ùT¬}¤¤7Ù™s_mÒ2Ò©ø.{óa:z¥+×_nä DıúÌ<á*»£ã9gz‹œ÷Âš} 7š÷“àşÎfŒú+	S u›…ˆ/’³µ<9æ“ˆ­1Éæ1W-	=;
LÙµ€Íñrò=†_ î\‚wq—¨üñë¼ãèšNñKXüd´”z…À[^¨ê›g†x‘ÜØVïbíìcÁ¬Å]™²g#¦D­-Â—5&Z$ê/VHW•Bk“ÒØòp­Â—¯ôôL	#)Çfá7ş—"ñ¯Áìè*óY;Q;â=ƒ’º	6$ïÈ—Ã}ù¸½32øƒÄ|)ÛŞpzÎb«ììÁŒƒÿ&Ô7#¢äâdíÃL§¿viõ|œİ[ á»srÄi¢Ø¨˜³Üİ¿Ä‡±ËS³rû0)ú£×Áµ}>eÌ<$’÷yúgÈ° ~lÀia!?ÇÉüS¶Î¶µò–6P1­Ï6y}|\–²–JEŒÔk›+½IÖ”g9œ#,-‚İNIõù•°­Ú ü1u‹pdrÀl¤şæ¬ÉÜ0'wÊèL3FËÒè¬oX•¿º©~y]¦G#gÿËóŒ®üÿ[\ß—ĞÊ.×Ì'_êÆeşñ¥|ÛÉ—i¿i[‘_¦[OäëoîÕrÁ“Ş}íş;şØ;óMm"7JÅj@Îœ›&òGùä‚g3y%Õ6!©­[•e¦d³¢?#ÓßUíÎwÂ¿JKl]•ò?b¬T½½Aß#çc¦„¥Gö­>nè²¿x÷¹[z`ñ ØôYŞú?N=Õ—nFIF>±™Üêyõµê‹8JŞMRê†]".R`;™ÈÔ2^”´0³eM‹¸èÈÙ¸Øÿz1×ĞÕ5K‹Õ\Åşg#›+šºj‡]¶Î#Z¥TBœ+ŒşëîÀêŞğ~øa|ª³†æW^£µ6œm—ƒS©¦Ftª¥Q©Gƒí§F·Ø©jh*)Rêİ§ª—A9£yª·ş×®ZªG3‹I¢ëœpEÁW"Ûn´²]jT+Š(¶¤V(ºª+,5¢øP·æ¢"Û¥óÃ·}Yl
Ãş2µèíÁl|»d2#õaÕÓ¸Õ¢X/º]Ö¦l~]@Æªü”4E$+*¢©7ñm¶ŞÛ´8K«]vq~oo·š¼¡‡vøWÜkÌPËÀ}áFA›*àôMn­³U(gp×ÙÍlÍ¶ï•?&ıÖ7„_üŸÛ¬‘Å6ñ“Ê¡	Ô£ğ€”wíë•jª®7Ó´Û$½ƒ¼4Ûí´š3|“Çq‡ß•>4‰g§òêıP¥[íÎVé„uvœ•‰îäÿ3Ñ@§ÄíÂrj«Ü0ìŞz ‰Ú»Y2«CÚÑıáh-/Àc¯0S|@h]÷Sı¤t¼BZ±Â„zcÏtàptÁ*f†W‰%Íõd;Ú6²³ÄPŞ9!o¸»Ó*\KãÏCx÷±Ö»
Åiv8ÀráŠ!0MªÙàŒ‰:­:hÏt‡§#d²–(Âë5;ƒ¶É	b´²Rth‰Š‹ÚûúˆDµW#=	×ò&¼şOŒ2ö´­Rónø¿ìAL ²×€Áp°ÊD°U›GëšÑşº¹hA<åÂ¾K7×9ŸÉ¬Ån^^tƒ‚ÖSE8Ï‰İXÃ^¬ÚHÿ¢Ls¢‘ïË¬©›îNQÃÉÈ±4bFÍ:†úÛÆè î3m,µñ¤a­(Bµoíønt'7wëæ-gbvÃ%·óVõ’ıÏ «ñ=oË„}¢Ñ®d8›en¿4ùí^óA´ÏmQŞ’Eü9DÌ`3‚Ë+Ec»X\‹³&èevğ8;è)
:Söö€[+‹1•{ÎŠ€ÏØwªL#9På¾Õ™==’#·úVçÃXoî|àhnAãmTØŒ·ä¼è¦ö°’{zëâ?V‹=º´_İ]AJĞ=Û7TV3”™˜õ!˜ßä…›ğ:û\a/×ÎXN²Â3sk…´Ğ&²Â3¯š“Ø¾fsÖG¦÷$+dçï!ÑôÁ5âU.=¥UpwÌŞsáª¾Ğhş­}uÅÿÉ¹‡˜·|„Kš±Äô¾ÕX)î½¥_RîMÄ”ö¢Ã¶w©=j¢¶¥"²º³DHóºè_,‘[`UÈaJM•ğ×Ql‚&XÃ©L§6äÜ…y]ê}Ô¯7ÕÂºO`*
—m«e„oY>ÔB¢`[!Ñto«loœ²ø¬.ûÙX¶>É¯Ûä¬ãüíİº¤:íÚÏv´ˆcòªdaÙû@ CNT½!HZ°1Ø(¹AT¤‡¿å ˜  ‡‰xˆ—™ši‡º‰‹˜©©»—ª¦›‡Ì¹˜x»«šxœ«ªg‰‡ˆešu™˜›™ˆ™«˜™¨¼šš©¹¹™©™‡Œ‰š¸‰—y‡ÊXii»º«É««°º»Ê»ËºÊ»¬º««¹˜	©«wˆˆx˜©¨ªˆ©©™©»ª¨ššºu›‰º‰™ª™w¨˜y À   Ì       ¹       ¨»     ˜ª     —«Ë    v˜ªªÀ°°w˜¬»«°v˜
Ê° Àv˜É
 v˜¹Ë  v¸ºÌ°À À©»                           *rpe³ ¾‡ïf%x-Ôç.æéñ¦g \µä.'ÓRN½•àˆ÷f1M¢d2êÃi:=+*ñ¦È2	n`•¼­j8z¾åÚÀI®¶ò~fU²nÚ­>HÕ\Ñ¦­»œTÔˆKÕ&•´ª$¬ +@…"¯Ğ{Üm¢²MzAy~ãPİ(çÜ¥YIöôòé:™Âzu/Ÿ»hÌwY'şÇYuôÈÏöK•¿Ê'0êCeû^V¹mîß­·}£Ëo·¶ı)ğ™î´~´àd{àäÔdOäeÇ´m%œTY¾¾MÛÕ€ ŒLß¶>b˜ßYÜĞ2ØyUyÙ ZÄ[÷~ö}¦®¦#ú„w±xGÏ_49nÖ»İš‡¶?Õg<€ò`Â8MüĞëoÁ‡~æÚ?CwÛú|Ôåúïòò\=ŠnÛ?Ç± ¹Ç¶«ªB;h² VÿOÿåiÚ•m3ëÌ$ÕQƒÕä¥îÆ^jœ%¼‹ºLeƒ¾ÜàÍŒü¯Údß_êl¾5©å7Î<JmÇz2`CjxQX‚·å¶³}øš
§°œşãÜİ¸{âV55 p ?¸=·ô¢—as æÀÓãÖ¬K•z{;gÌw:¤0±.¹İ1ì@ÎXd1 Á0}2XT·glĞ	±ÊüÖïƒQî8~­d"@¸ŸYZ5iêXÁYS~ÑŸmğM8®Oòä`¶aşüñTqãĞ*cz–“Y7&+qFÈ€…ô?×~B "hş®ê¸3Ğ.³åpÛ¼ßø®…}jÙf@@2#VQ0™ÅÈì‹  2.	”ù‰üÊXÜğ¶²/2™×İÖ ?aÔÁJÕFnŒt‘FS×³¨èÓ$FO4yDß—†„'š|Ôô’@ dÚ˜¼PŠ>BştfÓJğ³šÂ¢voÊŸ˜:3U3`ó¶šÒ!sU¬Õ´KÏæ]¦N™İò¸7O”Â`àøã°O‡«ƒ~€¡ˆa!¥6¤õNÛİF£b¬ö`½ÈÖpXüKœÀotÃ9ÉZ€ëj.½‹ÆO•(ÏÀT_!İÃî@Y‰«±İSj`˜PVÿˆÀíHB€fêâmÍÁ½è¿÷©M>½@ğ£{Øª|æƒåw:Ì@„+ˆG¼ú9*98…[Ny(¡c=ó„“èüÛd{¨±íêÈƒšæQØú;½s:®ëËÃêÙqÜîš½ìMGßàÂ(Mš„Ïßo)øæûøãŒóáNH=UØàìµ_CS°©eµŠõãzı	ŞŠ¼f‚oÂ?¡‘°ÖáÈÑ÷µ~4‚¬õñö‡[Úzëïà8ÇCË›?}š¬×ï>.)?+t?âOÍİ kş5Ì-¼.~ğ«ğî?¬qÇŞ¾ì­ Æ0C›é‚¨Ô4•Ï8¬¿“Ï/î?óÍğ˜šÜ—¥Êz8Ê4‡®n3«>îå¯r1ø…¦±§éa-ùĞ¤O¿kFÃrğ™á"Wß2Ú|¥«GcAá8|¦
Îª¨œU›gß-GlŠª„ÿ7™‡ñPPT—ƒCõsÌcB×4Ï¬i‹ë/?7‰›¶îñ¨˜0ĞÕMÿ-ÉŠ—ÌÍâBÕ4M[g}qô<©ÔÃ£åáä©2tŸÊÑeÙ †‡C§wl*¢©Ó±xS^øqîõ‡fCÑ¬Ë`°Gˆ,†æZ,]f‚A2o9u ÷?5d‡Pd1@ ^ß	¢(È’¾Êuµ,K½ÁË`a½Ø9ç–ü&SáT2Yˆ²â*Qòİe{ÇïÎ‹6ØÛ"AšûB78©QT6A¨ÑŞå)ìQ-aFó^åğËä7[íxåÙèş|&ub½öV¨hˆú4+ß25u3yI•.“âe"Ñâ_^ÂJ‹°%¡DPíèŠDËÅ‘vÀRf¨Ö‚•»ÂÆÖ„ÃR˜iÀŞÂd¦º™\½ÎX).ì;FKM\‚!©œÀM’¹Ú³VSAM3ÍuşÆÔÍK]ôÜûÈ.ÙØ¡T¦=¨?´wÀì··ş´ Á÷û¶?¯ûe&ôcÎ¤WÀØ± GA±,²¬XÍ[E‹sŞ-ÈK³”×X£‡dà:^(åüæ„ÂûÌıû/À˜fÿ=<Ş‡²öúSµEN€ÛCÒd÷Â/â ÚW	s®°Ë9ÕGí„:_’Í&+2ÒÇKEÒÍ€’/‡dƒU1ˆ°U4S¿º‹`Où¡âm‚9	Åò[…yƒ%rJiäÁVÓ‚ÁÚ.	
 büå953‰S0¢ş¢Èò4íñ–ôe²Ëí-dI]pAÀù©¥sj´…*\«´½Kì‘açŸ